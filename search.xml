<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>公司任务</title>
    <url>/2023/02/25/test/Pandas%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<p>公司任务：有五个设备统计53周电器用电数据。现在要拆分到每周每种电器用电数据。 <span id="more"></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 五个设备的表格，按周分别拆分出53个表格，共计53*3=159个表格</span></span><br><span class="line">data1 = pd.read_excel(<span class="string">&quot;CRT2_OUTPUT (1).xlsx&quot;</span>)</span><br><span class="line">gb = data1.groupby(<span class="string">&#x27;FISCAL_WEEK&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> week,df_son <span class="keyword">in</span> gb:</span><br><span class="line">	df_son.to_excel(<span class="string">f&#x27;<span class="subst">&#123;week&#125;</span>.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 再给五个设备合并</span></span><br><span class="line">path = <span class="string">&#x27;./APS2&#x27;</span> </span><br><span class="line">dlj = os.listdir(path)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dlj:</span><br><span class="line">    name1=<span class="string">&#x27;./APS2/&#x27;</span>+i</span><br><span class="line">    data1 = pd.read_excel(name1)</span><br><span class="line">    name2=<span class="string">&#x27;./CART2/&#x27;</span>+i</span><br><span class="line">    data2 = pd.read_excel(name2)</span><br><span class="line">    name3=<span class="string">&#x27;./FIN2/&#x27;</span>+i</span><br><span class="line">    data3 = pd.read_excel(name3)</span><br><span class="line">    name4=<span class="string">&#x27;./ODT2/&#x27;</span>+i</span><br><span class="line">    data4 = pd.read_excel(name4)</span><br><span class="line">    name5=<span class="string">&#x27;./PRE2/&#x27;</span>+i</span><br><span class="line">    data5 = pd.read_excel(name5)</span><br><span class="line">    datanew = pd.concat([data1,data2,data3,data4,data5], axis=<span class="number">0</span>)</span><br><span class="line">    datanew.to_excel(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 再分别计算五个设备的和    </span></span><br><span class="line">path = <span class="string">&#x27;./MERGE&#x27;</span> </span><br><span class="line">dlj = os.listdir(path)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dlj:</span><br><span class="line">    name1=<span class="string">&#x27;./MERGE/&#x27;</span>+i</span><br><span class="line">    data1 = pd.read_excel(name1)</span><br><span class="line">    datanew = data1.groupby([<span class="string">&#x27;PART_NUM&#x27;</span>])[<span class="string">&#x27;OUTPUT&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">    datanew.to_excel(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 再将53周合并到一个表格里，这里因为每周电器设备不同，用concat不太好，改用merge。</span></span><br><span class="line">path = <span class="string">&#x27;G:/桌面/e/type2/MERGE_SUM/&#x27;</span> </span><br><span class="line">dlj = os.listdir(path)</span><br><span class="line">datanew = pd.read_excel(<span class="string">&#x27;2.xlsx&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dlj:</span><br><span class="line">    name1 = path+i</span><br><span class="line">    data1 = pd.read_excel(name1)</span><br><span class="line">    datanew = pd.merge(datanew, data1, how=<span class="string">&#x27;outer&#x27;</span>, on=[<span class="string">&#x27;PART_NUM&#x27;</span>])</span><br><span class="line">datanew.to_excel(<span class="string">&#x27;a.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>Pandas</category>
      </categories>
  </entry>
  <entry>
    <title>R语言-时间序列分析</title>
    <url>/2023/03/24/test/R%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文介绍时间序列模型的基本r语言代码，包括平稳性和非平稳性的处理。</p>
<span id="more"></span>

<h1 id="一个完整的Arma模型分析处理"><a href="#一个完整的Arma模型分析处理" class="headerlink" title="一个完整的Arma模型分析处理"></a>一个完整的Arma模型分析处理</h1><h2 id="arma模型平稳性判别"><a href="#arma模型平稳性判别" class="headerlink" title="arma模型平稳性判别"></a>arma模型平稳性判别</h2><h2 id="1-时序图绘制"><a href="#1-时序图绘制" class="headerlink" title="1. 时序图绘制"></a>1. 时序图绘制</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 时间序列的赋值</span></span><br><span class="line">rain<span class="operator">&lt;-</span>ts<span class="punctuation">(</span>data<span class="operator">$</span>price<span class="punctuation">,</span>start<span class="operator">=</span><span class="number">2015</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 时间序列的子序列</span></span><br><span class="line">rain2<span class="operator">&lt;-</span>window<span class="punctuation">(</span>rain<span class="punctuation">,</span>start<span class="operator">=</span><span class="number">2016</span><span class="punctuation">,</span>end<span class="operator">=</span><span class="number">2018</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># data表格的price列，开始是2015年</span></span><br><span class="line"><span class="comment"># 2. 绘制</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>



<h2 id="3-噪声检验（纯随机检验）"><a href="#3-噪声检验（纯随机检验）" class="headerlink" title="3. 噪声检验（纯随机检验）"></a>3. 噪声检验（纯随机检验）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>k <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span> print<span class="punctuation">(</span>Box.test<span class="punctuation">(</span>white_noise<span class="punctuation">,</span>lag<span class="operator">=</span><span class="number">6</span><span class="operator">*</span>k<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&quot;Ljung-Box&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="comment">#噪声检验</span></span><br><span class="line"><span class="comment"># type=&#x27;Box-Pierce&#x27;是Q检验量</span></span><br><span class="line"><span class="comment">## 输出LB统计量和P值</span></span><br><span class="line"><span class="comment">## p值大于0.05则不能拒绝</span></span><br></pre></td></tr></table></figure>

<p>结果分析：显示延迟6和12阶的LB统计量的P值<strong>小于</strong>显著性水平（α &#x3D; 0.05)，所以可以判断该序列为平稳非白噪声序列。</p>
<h3 id="DF-x2F-ADF平稳性检验"><a href="#DF-x2F-ADF平稳性检验" class="headerlink" title="DF&#x2F;ADF平稳性检验"></a>DF&#x2F;ADF平稳性检验</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;aTSA&#x27;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>aTSA<span class="punctuation">)</span></span><br><span class="line">adf.test<span class="punctuation">(</span>overshort<span class="punctuation">,</span>nlag<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># P值为0.01小于0.05，所以该序列平稳</span></span><br></pre></td></tr></table></figure>
<p>DF检验针对AR(1)，是ADF的特例。<br>结果分析：6中子类型，τ统计量的<strong>P值均显著大于显著性水平</strong>（α &#x3D; 0.05)，因此可以判断，如果序列考虑如上6种结构之一提取确定性信息，则随机性部分都不能实现平稳。<br>所以序列是<strong>非平稳序列</strong>。<br>若存在小于显著性水平的，则是平稳序列。</p>
<h2 id="2-自相关图and偏自相关图（模型定阶）"><a href="#2-自相关图and偏自相关图（模型定阶）" class="headerlink" title="2. 自相关图and偏自相关图（模型定阶）"></a>2. 自相关图and偏自相关图（模型定阶）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lag延迟阶数</span></span><br><span class="line"><span class="comment"># plot=True，只输出自相关图，不输出系数；False，反之。</span></span><br><span class="line">acf<span class="punctuation">(</span>x<span class="punctuation">,</span>lag.max<span class="operator">=</span><span class="punctuation">,</span>plot<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line">pacf<span class="punctuation">(</span>x<span class="punctuation">,</span>lag.max<span class="operator">=</span><span class="punctuation">,</span>plot<span class="operator">=</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>结果分析：<br>判断是截尾还是拖尾，然后分析模型属于哪一种。</p>
<p>自相关图是自相关系数，虚线是自相关系数两倍标准差的参考线。落在两倍标差外，则认为自相关系数很大，显著非零。</p>
<h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x.fit<span class="operator">&lt;-</span>arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># order为模型阶数:自回归阶数、差分阶数、移动平均阶数。</span></span><br><span class="line"><span class="comment"># include.mean要不要包含均值</span></span><br><span class="line"><span class="comment"># method=&quot;CSS-ML&quot;最小二乘和极大似然的混合 也可以单独使用一种</span></span><br></pre></td></tr></table></figure>
<h3 id="模型检验：残差分析"><a href="#模型检验：残差分析" class="headerlink" title="模型检验：残差分析"></a>模型检验：残差分析</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>aTSA<span class="punctuation">)</span></span><br><span class="line">ts.diag<span class="punctuation">(</span>x.fit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果输出四图</p>
<p>ACF&#x2F;PACF图：需要所有竖线全都在<strong>蓝色虚线内</strong>(95%CI)。</p>
<p>第三幅图：残差序列的白噪声检验，观察各阶延迟下的白噪声检验统计量的<strong>P值是否都显著的大于0.05</strong>。若都显著，则残差序列属于白噪音序列，拟合模型显著成立。<br>第四幅图：QQ图，正态分布假定的检验。如果点<strong>密集地分布在对角线左右</strong>，则该序列近似服从正态分布。</p>
<h3 id="参数的显著性检验"><a href="#参数的显著性检验" class="headerlink" title="参数的显著性检验"></a>参数的显著性检验</h3><p>检验每一个未知参数是否显著非零<br>目的：精简模型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 近似方法</span></span><br><span class="line">x.fit</span><br><span class="line"><span class="comment"># 2. 精确方法</span></span><br><span class="line"><span class="comment"># 构造t统计量，调用pt函数求p值</span></span><br><span class="line">t <span class="operator">=</span> <span class="built_in">abs</span><span class="punctuation">(</span>fit<span class="operator">$</span>coef<span class="punctuation">)</span><span class="operator">/</span><span class="built_in">sqrt</span><span class="punctuation">(</span>diag<span class="punctuation">(</span>fit2<span class="operator">$</span>var.coef<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">pt<span class="punctuation">(</span>t<span class="punctuation">,</span><span class="built_in">length</span><span class="punctuation">(</span>overshort<span class="punctuation">)</span><span class="operator">-</span><span class="built_in">length</span><span class="punctuation">(</span>fit1<span class="operator">$</span>coef<span class="punctuation">)</span><span class="punctuation">,</span>lower.tail<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># t统计量的值，自由度，参数估计值为正</span></span><br></pre></td></tr></table></figure>
<h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BIC<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">AIC<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="识别最优阶数"><a href="#识别最优阶数" class="headerlink" title="识别最优阶数"></a>识别最优阶数</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.package<span class="punctuation">(</span><span class="string">&#x27;forecast&#x27;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>forecast<span class="punctuation">)</span></span><br><span class="line">auto.arima<span class="punctuation">(</span>x<span class="punctuation">,</span>ic<span class="operator">=</span><span class="string">&#x27;bic&#x27;</span><span class="punctuation">)</span></span><br><span class="line">auto.arima<span class="punctuation">(</span>x<span class="punctuation">,</span>ic<span class="operator">=</span><span class="string">&#x27;aic&#x27;</span><span class="punctuation">)</span><span class="comment"># 默认</span></span><br></pre></td></tr></table></figure>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>forecast<span class="punctuation">)</span></span><br><span class="line">fore<span class="operator">&lt;-</span>forecast<span class="operator">::</span>forecast<span class="punctuation">(</span>fit<span class="punctuation">,</span>h<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span><span class="comment">#预测未来十个数据</span></span><br><span class="line">plot<span class="punctuation">(</span>x.fore<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="非平稳处理"><a href="#非平稳处理" class="headerlink" title="非平稳处理"></a>非平稳处理</h1><h2 id="线性拟合"><a href="#线性拟合" class="headerlink" title="线性拟合"></a>线性拟合</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 40年</span></span><br><span class="line">t <span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">40</span><span class="punctuation">)</span></span><br><span class="line">x.fit <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>x<span class="operator">~</span>t<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 查看拟合信息</span></span><br><span class="line">summary<span class="punctuation">(</span>x.fit<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 画拟合图</span></span><br><span class="line">x <span class="operator">&lt;-</span> ts<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">abline<span class="punctuation">(</span>lm<span class="punctuation">(</span>x<span class="operator">~</span>t<span class="punctuation">)</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><h3 id="可用线性最小二乘"><a href="#可用线性最小二乘" class="headerlink" title="可用线性最小二乘"></a>可用线性最小二乘</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t1<span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">60</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 转化</span></span><br><span class="line">t2<span class="operator">&lt;-</span>t1<span class="operator">^</span><span class="number">2</span></span><br><span class="line">x.fit1<span class="operator">&lt;-</span>;m<span class="punctuation">(</span>x<span class="operator">~</span>t1<span class="operator">+</span>t2<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>x.fit1<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="不可用线性最小二乘"><a href="#不可用线性最小二乘" class="headerlink" title="不可用线性最小二乘"></a>不可用线性最小二乘</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x.fit2<span class="operator">&lt;-</span>nls<span class="punctuation">(</span>x<span class="operator">~</span>a<span class="operator">+</span>b<span class="operator">*</span>t1<span class="operator">+</span><span class="built_in">c</span><span class="operator">*</span>t1<span class="operator">^</span><span class="number">2</span><span class="punctuation">,</span>start<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>a<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>b<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span><span class="built_in">c</span><span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>x.fit2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 画图</span></span><br><span class="line">y<span class="operator">&lt;-</span>predict<span class="punctuation">(</span>x.fit2<span class="punctuation">)</span><span class="comment">#把nls函数得到的拟合值赋值给y</span></span><br><span class="line">y<span class="operator">&lt;-</span>ts<span class="punctuation">(</span>y<span class="punctuation">,</span>start<span class="operator">=</span><span class="number">1949</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&quot;p&quot;</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>y<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="移动平均拟合"><a href="#移动平均拟合" class="headerlink" title="移动平均拟合"></a>移动平均拟合</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动平均拟合</span></span><br><span class="line">library<span class="punctuation">(</span>TTR<span class="punctuation">)</span></span><br><span class="line">x<span class="operator">&lt;-</span></span><br><span class="line"><span class="comment"># 选择期数 进行拟合</span></span><br><span class="line">x.ma<span class="operator">&lt;-</span>SMA<span class="punctuation">(</span>x<span class="punctuation">,</span>n<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>tyoe<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>x.ma<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指数平滑"><a href="#指数平滑" class="headerlink" title="指数平滑"></a>指数平滑</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x<span class="operator">&lt;-</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span>x<span class="punctuation">,</span>alpha<span class="operator">=</span><span class="punctuation">,</span> beta<span class="operator">=</span><span class="punctuation">,</span> <span class="built_in">gamma</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span>seasonal<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 简单指数平滑</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span>x<span class="punctuation">,</span>beta<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">gamma</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Holt两参数平滑</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span><span class="built_in">gamma</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Holt&#x27;三参数平滑</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># seasonal：季节和趋势的关系</span></span><br><span class="line"><span class="comment"># seasonal=&#x27;additive&#x27;;seasonal=&#x27;multiplicative&#x27;</span></span><br><span class="line"><span class="comment"># 默认加法，seasonal=&#x27;mult&#x27;乘法</span></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line">plot<span class="punctuation">(</span>x.fit<span class="punctuation">)</span></span><br><span class="line">x.fore<span class="operator">&lt;-</span>forecast<span class="punctuation">(</span>x.fit<span class="punctuation">,</span>h<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x.fore<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="季节指数、趋势效应、随机效应分解"><a href="#季节指数、趋势效应、随机效应分解" class="headerlink" title="季节指数、趋势效应、随机效应分解"></a>季节指数、趋势效应、随机效应分解</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> ts<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 乘法模型</span></span><br><span class="line">x.fit <span class="operator">&lt;-</span> decompose<span class="punctuation">(</span>x<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;mult&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 加法模型</span></span><br><span class="line">x.fit <span class="operator">&lt;-</span> decompose<span class="punctuation">(</span>x<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;addi&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以查看季节指数、趋势效应、随机效应</span></span><br><span class="line">x.fit<span class="operator">$</span>figure</span><br><span class="line">x.fit<span class="operator">$</span>trend</span><br><span class="line">x.fit<span class="operator">$</span>random</span><br></pre></td></tr></table></figure>

<h2 id="无季节效应差分运算"><a href="#无季节效应差分运算" class="headerlink" title="无季节效应差分运算"></a>无季节效应差分运算</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">diff<span class="punctuation">(</span>x<span class="punctuation">,</span>d<span class="punctuation">,</span>k<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 进行k次d步差分</span></span><br></pre></td></tr></table></figure>

<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> ts<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画原时间序列</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 原时序图有线性趋势</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1阶差分</span></span><br><span class="line">x.dif<span class="operator">&lt;-</span>diff<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1阶差分后的时序图\自相关图和偏相关图</span></span><br><span class="line">plot<span class="punctuation">(</span>x.dif<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 时序图在均值附近稳定波动</span></span><br><span class="line"></span><br><span class="line">acf<span class="punctuation">(</span>x.dif<span class="punctuation">)</span></span><br><span class="line">pacf<span class="punctuation">(</span>x.dif<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 观察截尾拖尾性质，判断拟合模型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="punctuation">,</span>transform.par<span class="operator">=</span><span class="punctuation">,</span>fixed<span class="operator">=</span><span class="punctuation">,</span>seasonal<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># order为非季节效应部分的模型阶数</span></span><br><span class="line"><span class="comment"># 是否需要拟合常数项，参数估计方法，是否需要人为干预参数估计，疏系数模型指定疏系数的位置</span></span><br><span class="line"><span class="comment"># seasonal =  list(order=c(P,D,Q),period=s)</span></span><br><span class="line"><span class="comment"># 加法：p=0,q=o;乘法:p/q不全为0</span></span><br><span class="line"><span class="comment"># 拟合</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>arima<span class="punctuation">(</span>x<span class="punctuation">,</span>orderc<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 有季节因素的乘法模型</span></span><br><span class="line">fit2 <span class="operator">&lt;-</span>arima<span class="punctuation">(</span>x3<span class="punctuation">,</span>order <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>seasonal<span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>order <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>period <span class="operator">=</span><span class="number">12</span><span class="punctuation">)</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="string">&#x27;ML&#x27;</span><span class="punctuation">)</span><span class="comment">#经过多次试探性降阶尝试，拟合AIC值较</span></span><br><span class="line"><span class="comment"># 残差白噪声检验</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span> print<span class="punctuation">(</span>Box.test<span class="punctuation">(</span>x.fit<span class="punctuation">,</span>lag<span class="operator">=</span><span class="number">6</span><span class="operator">*</span>i<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 白噪声p值大于0.05：显著成立才算拟合成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">x<span class="punctuation">,</span>fore<span class="operator">&lt;-</span>forecast<span class="punctuation">(</span>x.fit<span class="punctuation">,</span>h<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测图</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="根据拟合结果写出拟合模型"><a href="#根据拟合结果写出拟合模型" class="headerlink" title="根据拟合结果写出拟合模型"></a>根据拟合结果写出拟合模型</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x.fit</span><br><span class="line"><span class="comment"># 观察输出</span></span><br></pre></td></tr></table></figure>

<h3 id="疏系数"><a href="#疏系数" class="headerlink" title="疏系数"></a>疏系数</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="punctuation">,</span>transform.pars<span class="operator">=</span><span class="punctuation">,</span>fixed<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">-</span>x<span class="operator">:</span>要进行模型拟合的序列名，</span><br><span class="line"><span class="operator">-</span>order<span class="operator">:</span></span><br><span class="line">指定模型阶数。order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>p为自回归阶数，d为差分阶数，q为移动平均阶数。</span><br><span class="line"><span class="operator">-</span>include<span class="punctuation">,</span>mean<span class="operator">:</span></span><br><span class="line">include.mean<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">,</span>需要拟合常数项；include.mean<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span>不需要拟合常数项，</span><br><span class="line"><span class="operator">-</span>method<span class="operator">:</span>指定参数估计方法，</span><br><span class="line"><span class="operator">-</span>transform<span class="punctuation">,</span>pars<span class="operator">:</span>指定参数估计是否由系统自动完成，</span><br><span class="line"><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span>transform.pars<span class="operator">=</span><span class="built_in">T</span><span class="operator">:</span>系统默认设置是系统根据order选项设置的模型阶数自动完成参数估计。</span><br><span class="line"><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span>transform<span class="punctuation">,</span>pars<span class="operator">=</span><span class="built_in">F</span><span class="operator">:</span>需要拟合疏系数模型，不能让系统根据模型的最高阶数自动完成所有参数的估计，我们需要进行人为干预，</span><br><span class="line"><span class="operator">-</span>fixed：对疏系数模型指定疏系数的位置。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若偏自相关图，除了1阶和4阶偏自相关系数显著大于2倍标准差，其他阶数的偏自相关系数基本都在2倍标差范围内波动，疏系数AR(1,4)</span></span><br><span class="line"><span class="comment"># 疏系数模型</span></span><br><span class="line"><span class="comment">## ARIMA((1,4),1,0)</span></span><br><span class="line">fit <span class="operator">&lt;-</span> arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>transform.pars<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span>fixed<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># transform.pars=F 人为干预</span></span><br><span class="line"><span class="comment">#fixed=c(NA,0,0,NA):只有1，4两个参数非零；2，3两个参数恒等于0</span></span><br><span class="line"><span class="comment">## # ARIMA(3,2,(1,2,6,7))</span></span><br><span class="line">g.fit4<span class="operator">&lt;-</span>arima<span class="punctuation">(</span>lng<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">)</span><span class="punctuation">,</span>transform.pars <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">,</span>fixed <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="comment"># 包含了p的三个系数</span></span><br></pre></td></tr></table></figure>

<h2 id="移动平均提取趋势"><a href="#移动平均提取趋势" class="headerlink" title="移动平均提取趋势"></a>移动平均提取趋势</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单移动平均</span></span><br><span class="line"><span class="comment"># 简单移动平均就是将n个观测值的平均数作为第（n+1）/2个的拟合值。当n为偶数时，需进行二次移动平均。</span></span><br><span class="line">m4 <span class="operator">&lt;-</span> fliter<span class="punctuation">(</span>x<span class="operator">/</span><span class="number">5</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2*4复合移动平均</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先4（周期长度）</span></span><br><span class="line">m4 <span class="operator">&lt;-</span> fliter<span class="punctuation">(</span>x<span class="operator">/</span><span class="number">4</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 再2</span></span><br><span class="line">m2_4 <span class="operator">&lt;-</span> fliter<span class="punctuation">(</span>x4<span class="operator">/</span><span class="number">2</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span>sides<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># sides = 1或者2，“1”表示单边卷积，“2”表示双边卷积</span></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">dataframe<span class="punctuation">(</span>x<span class="punctuation">,</span>m2_4<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制移动效果</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>m2_4<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 残差序列图</span></span><br><span class="line"><span class="comment"># 原序列-趋势效应 = 季节效应+随机波动</span></span><br><span class="line">x_t <span class="operator">&lt;-</span> x<span class="operator">-</span>m2_4</span><br><span class="line">plot<span class="punctuation">(</span>x_t<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="加法季节"><a href="#加法季节" class="headerlink" title="加法季节"></a>加法季节</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x.t为剔除趋势效应的原序列</span></span><br><span class="line">x.t<span class="operator">&lt;-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 剔除缺失值，求总均值m</span></span><br><span class="line">m<span class="operator">&lt;-</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每个季节的均值ms</span></span><br><span class="line">ms <span class="operator">&lt;-</span> 0</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>k <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span>ms<span class="punctuation">[</span>k<span class="punctuation">]</span><span class="operator">=</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">[</span><span class="punctuation">,</span>k<span class="punctuation">]</span><span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 季节指数</span></span><br><span class="line">S<span class="operator">&lt;-</span>ms<span class="operator">-</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四个季节指数</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span>S<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机效应</span></span><br><span class="line">I<span class="operator">&lt;-</span>x<span class="operator">-</span>m2_4<span class="operator">-</span>S</span><br><span class="line">plot<span class="punctuation">(</span>I<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>



<h3 id="乘法模型"><a href="#乘法模型" class="headerlink" title="乘法模型"></a>乘法模型</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x.t为剔除趋势效应的原序列</span></span><br><span class="line">x.t<span class="operator">&lt;-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 剔除缺失值，求总均值m</span></span><br><span class="line">m<span class="operator">&lt;-</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每个季节的均值ms</span></span><br><span class="line">ms <span class="operator">&lt;-</span> 0</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>k <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span>ms<span class="punctuation">[</span>k<span class="punctuation">]</span><span class="operator">=</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">[</span><span class="punctuation">,</span>k<span class="punctuation">]</span><span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 季节指数</span></span><br><span class="line">S<span class="operator">&lt;-</span>ms<span class="operator">/</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12个季节指数</span></span><br><span class="line">Month <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">12</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Month<span class="punctuation">,</span>S<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机效应</span></span><br><span class="line">I<span class="operator">&lt;-</span>x<span class="operator">/</span>m2_12<span class="operator">/</span>S</span><br><span class="line">plot<span class="punctuation">(</span>I<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="异方差模型"><a href="#异方差模型" class="headerlink" title="异方差模型"></a>异方差模型</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>moments<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rugarch<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>fGarch<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>FinTS<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#LM检验(拉格朗日乘子检验)</span></span><br><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span> print<span class="punctuation">(</span>ArchTest<span class="punctuation">(</span>lnr_d<span class="punctuation">,</span>lag<span class="operator">=</span>i<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># LM检验显示ARCH模型的P值均小于0.05，显著成立，这说明残差平方序列具有短期相关性，可以用ARCH模型提取残差平方序列中蕴含的相关关系。</span></span><br><span class="line"><span class="comment"># 拟合arch(1)模型</span></span><br><span class="line">spec2<span class="operator">&lt;-</span>ugarchspec<span class="punctuation">(</span>mean.model <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>armaOrder<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">,</span>variance.model <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>garchOrder<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>model<span class="operator">=</span><span class="string">&quot;sGARCH&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>distribution.model<span class="operator">=</span><span class="string">&quot;norm&quot;</span><span class="punctuation">)</span></span><br><span class="line">fit4<span class="operator">&lt;-</span>ugarchfit<span class="punctuation">(</span>spec2<span class="punctuation">,</span>data<span class="operator">=</span>lnr_d<span class="punctuation">,</span>method<span class="operator">=</span><span class="string">&quot;ML&quot;</span><span class="punctuation">)</span></span><br><span class="line">fit4</span><br><span class="line">fit4<span class="operator">@</span>fit<span class="operator">$</span>matcoef</span><br><span class="line">plot<span class="punctuation">(</span>fit4<span class="punctuation">,</span>which<span class="operator">=</span><span class="number">8</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>fit4<span class="punctuation">,</span>which<span class="operator">=</span><span class="number">9</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>fit4<span class="punctuation">,</span>which<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>ylim<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">300</span><span class="punctuation">,</span><span class="number">300</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1.96</span><span class="operator">*</span>sd<span class="punctuation">(</span>lnr<span class="punctuation">)</span><span class="punctuation">,</span><span class="number">1.96</span><span class="operator">*</span>sd<span class="punctuation">(</span>lnr<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">fore <span class="operator">&lt;-</span> ugarchforecast<span class="punctuation">(</span>fit4<span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多元"><a href="#多元" class="headerlink" title="多元"></a>多元</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&#x27;TSA&#x27;</span><span class="punctuation">)</span></span><br><span class="line">arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span><span class="punctuation">,</span>xtransf<span class="operator">=</span><span class="punctuation">,</span>transfer<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#xreg:输入变量名（不需做函数转移）</span></span><br><span class="line"><span class="comment">#xtransf：输入变量名（需做函数转移）</span></span><br><span class="line"><span class="comment">#transfer：指定转移函数的模型阶数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#单变量不需要转移函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span>data.frame<span class="punctuation">(</span>x1<span class="punctuation">,</span>x2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#两变量不需要转移函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xtransf<span class="operator">=</span>x<span class="punctuation">,</span>transfer<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>m<span class="punctuation">,</span>n<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#单变量，ARMA(m,n)转移函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xtransf<span class="operator">=</span>data.frame<span class="punctuation">(</span>x1<span class="punctuation">,</span>x2<span class="punctuation">)</span><span class="punctuation">,</span>transfer<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>m1<span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span>m2<span class="punctuation">,</span>n2<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#双变量，分别ARMA(m,n)函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span>x1<span class="punctuation">,</span>xtransf<span class="operator">=</span>x2<span class="punctuation">,</span>transfer<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>m<span class="punctuation">,</span>n<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#双变量，一个需要转移，一个不需要转移。</span></span><br><span class="line"></span><br><span class="line">x1<span class="operator">&lt;-</span>zlag<span class="punctuation">(</span>x<span class="punctuation">,</span>k<span class="punctuation">)</span></span><br><span class="line">x1<span class="operator">&lt;-</span>x1<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>k<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">y1<span class="operator">&lt;-</span>y<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>k<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#单变量，延迟k阶再ARMA(m,n)转移函数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>时间序列分析</category>
      </categories>
      <tags>
        <tag>时间序列分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS入门知识</title>
    <url>/2023/06/25/test/css%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p> 本博客介绍了CSS基本的用法，适合初学者入门学习。<span id="more"></span></p>
<p>reference:所有属性查找:<a href="https://www.w3school.com.cn/cssref/pr_align-content.asp">https://www.w3school.com.cn/cssref/pr_align-content.asp</a></p>
<h1 id="什么是css"><a href="#什么是css" class="headerlink" title="什么是css"></a>什么是css</h1><p>Cascading层叠<br>Style样式<br>Sheets列表</p>
<p>创建一个样式表</p>
<p>样式表分类：外部、内部、行内样式	</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>结构与样式分离的方式<br>便于后期维护与改版<br>可以用多套样式使网页有任意样式切换的效果</p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&#x27;css&#x27;&gt;</span><br><span class="line">p&#123;</span><br><span class="line">background-color:red;</span><br><span class="line">font-size:40px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>任何一个标签都可以作为样式选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归类选择器"><a href="#归类选择器" class="headerlink" title="归类选择器"></a>归类选择器</h3><p>class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p1&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;p class=“p1”&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>常用于超链接</p>
<p>选择整体</p>
<h4 id="a-link未访问的连接"><a href="#a-link未访问的连接" class="headerlink" title="a:link未访问的连接"></a>a:link未访问的连接</h4><h5 id="color"><a href="#color" class="headerlink" title="color"></a>color</h5><h4 id="a-visited已访问的连接"><a href="#a-visited已访问的连接" class="headerlink" title="a:visited已访问的连接"></a>a:visited已访问的连接</h4><h5 id="color-1"><a href="#color-1" class="headerlink" title="color"></a>color</h5><h4 id="hover鼠标悬停"><a href="#hover鼠标悬停" class="headerlink" title=":hover鼠标悬停"></a>:hover鼠标悬停</h4><p>不只是超链接</p>
<p>其他文本也可以用hover</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;--用于在鼠标悬停在类名为&quot;<span class="selector-class">.cart</span>&quot;的元素上时，对其子元素中类名为&quot;<span class="selector-class">.cart-list</span>&quot;的元素进行样式设置--&gt;</span><br><span class="line"><span class="selector-class">.cart</span><span class="selector-pseudo">:hover</span>&gt;<span class="selector-class">.cart-list</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">当鼠标悬停在搜索框 <span class="selector-tag">input</span> 上时，它的相邻元素 <span class="selector-tag">a</span> 的样式会改变，包括背景颜色、边框颜色和文字颜色等。</span><br><span class="line"><span class="selector-class">.search</span>&gt;<span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>+<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#b0b0b0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="active激活"><a href="#active激活" class="headerlink" title=":active激活"></a>:active激活</h4><p>点击的时候</p>
<h4 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h4><p>点击后，常用于文本录入提示</p>
<h3 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h3><h4 id="first-child"><a href="#first-child" class="headerlink" title=":first-child"></a>:first-child</h4><p>所有标签中第一个</p>
<h4 id="last-child"><a href="#last-child" class="headerlink" title=":last-child"></a>:last-child</h4><p>所有标签中最后一个</p>
<h4 id="nth-child"><a href="#nth-child" class="headerlink" title=":nth-child()"></a>:nth-child()</h4><p>选择特定的</p>
<h4 id="nth-last-child"><a href="#nth-last-child" class="headerlink" title=":nth-last-child()"></a>:nth-last-child()</h4><p>选择特定的 从最后一个开始算</p>
<p>:nth-last-child(2)</p>
<h4 id="first-of-type"><a href="#first-of-type" class="headerlink" title=":first-of-type"></a>:first-of-type</h4><p>选择一个上级元素下的第一个同类子元素</p>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>只不过伪元素多加了一个content属性，如果我们对他不进行设置，那么我们设置的伪元素就会不起作用，我们可以设置content的内容为一个空字符串</p>
<h4 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h4><p>选择指定元素中被用户选中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::selection&#123;</span><br><span class="line">background-color:red;&#125;</span><br><span class="line">&lt;!--选中则加红--&gt;</span><br></pre></td></tr></table></figure>

<h4 id="before"><a href="#before" class="headerlink" title="::before"></a>::before</h4><p>可以在内容之前插入新内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::before&#123;</span><br><span class="line">content:&quot;终于找到你&quot;;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h4><p>可以在内容之后插入新内容</p>
<h4 id="first-line"><a href="#first-line" class="headerlink" title="::first-line"></a>::first-line</h4><p>选择指定选择器的首行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-line&#123;</span><br><span class="line">background-color:yellow;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="first-letter"><a href="#first-letter" class="headerlink" title="::first-letter"></a>::first-letter</h4><p>选择文本的第一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-letter&#123;</span><br><span class="line">font-size:30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h3><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>不允许重复的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#name&#123;</span><br><span class="line">color:red</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">&lt;p class=&#x27;p1&#x27; id=&#x27;name&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通配符"><a href="#通配符" class="headerlink" title="*通配符"></a>*通配符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--默认所有统一的字体字号--&gt;</span><br><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="逗号选择器"><a href="#逗号选择器" class="headerlink" title="逗号选择器"></a>逗号选择器</h4><p>联合选择器</p>
<h4 id="空格选择器"><a href="#空格选择器" class="headerlink" title="空格选择器"></a>空格选择器</h4><p>子孙（后代）选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#div1 p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-选择器"><a href="#gt-选择器" class="headerlink" title="&gt;选择器"></a>&gt;选择器</h4><p>子选择器（不包含孙后代）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--不含在div1中div2，div3的范围--&gt;</span><br><span class="line">#div1&gt;p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="+兄弟选择器"></a>+兄弟选择器</h4><p>相邻兄弟选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--和div1同级别的p--&gt;</span><br><span class="line">#div1+p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="兄弟选择器-1"><a href="#兄弟选择器-1" class="headerlink" title="~兄弟选择器"></a>~兄弟选择器</h4><p>所有同级的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示某元素后所有同级的指定元素，选中的是所有的</span><br><span class="line">选中h2下面的所有p ： h2~p&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#btnScrollToTop:checked ~ #top &#123;</span><br><span class="line">  scroll-behavior: smooth;</span><br><span class="line">  scroll-margin-top: 100px; </span><br><span class="line">&#125;</span><br><span class="line">当复选框 #btnScrollToTop 处于选中状态（即被勾选）时，对具有 #top ID 的元素应用样式</span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title="[]"></a>[]</h4><p>属性选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p[class=&#x27;p1&#x27;]&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><h4 id="强制优先"><a href="#强制优先" class="headerlink" title="强制优先"></a>强制优先</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">background-coLor:yellow!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同级别"><a href="#同级别" class="headerlink" title="同级别"></a>同级别</h4><p>后出现的会覆盖之前的设置</p>
<h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p> 1<br>!important<br>2<br>行内样式<br>3<br>ID选择器<br>4<br>类选择器<br>5<br>标签<br>6<br>通配符<br>7<br>浏览器默认属性</p>
<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.price2&gt;del&#123;</span><br><span class="line">    color: #b0b0b0;</span><br><span class="line">    margin-left: 6px;</span><br><span class="line">&#125;</span><br><span class="line">对类名为&quot;.price2&quot;的元素下的&quot;del&quot;标签进行样式设置:删除线</span><br></pre></td></tr></table></figure>



<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="背景background"><a href="#背景background" class="headerlink" title="背景background"></a>背景background</h3><h4 id="background-color：背景颜色"><a href="#background-color：背景颜色" class="headerlink" title="background-color：背景颜色"></a>background-color：背景颜色</h4><h4 id="background-image：背景图片"><a href="#background-image：背景图片" class="headerlink" title="background-image：背景图片"></a>background-image：背景图片</h4><h4 id="background-repeat：重复方向"><a href="#background-repeat：重复方向" class="headerlink" title="background-repeat：重复方向"></a>background-repeat：重复方向</h4><h4 id="background-attachment：背景是否随滚动条滚动"><a href="#background-attachment：背景是否随滚动条滚动" class="headerlink" title="background-attachment：背景是否随滚动条滚动"></a>background-attachment：背景是否随滚动条滚动</h4><h4 id="background-position：背景图片的起始位置"><a href="#background-position：背景图片的起始位置" class="headerlink" title="background-position：背景图片的起始位置"></a>background-position：背景图片的起始位置</h4><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="color文本颜色"><a href="#color文本颜色" class="headerlink" title="color文本颜色"></a>color文本颜色</h4><h4 id="direction文本方向"><a href="#direction文本方向" class="headerlink" title="direction文本方向"></a>direction文本方向</h4><p>ltr、rtl(对阿拉伯数字和符号有效，逆序)</p>
<h4 id="letter-spacing字符间距"><a href="#letter-spacing字符间距" class="headerlink" title="letter-spacing字符间距"></a>letter-spacing字符间距</h4><p>npx</p>
<h4 id="line-height行高"><a href="#line-height行高" class="headerlink" title="line-height行高"></a>line-height行高</h4><p>npx</p>
<h4 id="text-align文本对齐"><a href="#text-align文本对齐" class="headerlink" title="text-align文本对齐"></a>text-align文本对齐</h4><p>left</p>
<p>right</p>
<p>center</p>
<p>justify两端对齐 </p>
<h4 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h4><p>underline下划线</p>
<p>overline</p>
<p>line-through</p>
<h4 id="text-shadow阴影"><a href="#text-shadow阴影" class="headerlink" title="text-shadow阴影"></a>text-shadow阴影</h4><p>5px 5px 10px red </p>
<h4 id="text-transform字母大小写"><a href="#text-transform字母大小写" class="headerlink" title="text-transform字母大小写"></a>text-transform字母大小写</h4><p>capitalize</p>
<p>uppercase</p>
<p>lowercase</p>
<h4 id="text-indent首行缩进"><a href="#text-indent首行缩进" class="headerlink" title="text-indent首行缩进"></a>text-indent首行缩进</h4><p>npx</p>
<p>nem（字符数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;--!法1--&gt;</span><br><span class="line">top left</span><br><span class="line">tap center</span><br><span class="line">top right</span><br><span class="line">center left</span><br><span class="line">center center</span><br><span class="line">center right</span><br><span class="line">bottom left</span><br><span class="line">bottom center</span><br><span class="line">bottom right</span><br><span class="line">&lt;--!法2--&gt;</span><br><span class="line">x% y%</span><br><span class="line">&lt;--!法3--&gt;</span><br><span class="line">xpos ypos</span><br></pre></td></tr></table></figure>

<h4 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h4><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">clip</td>
<td align="left">修剪文本。</td>
</tr>
<tr>
<td align="left">ellipsis</td>
<td align="left">显示省略符号来代表被修剪的文本。</td>
</tr>
<tr>
<td align="left"><em>string</em></td>
<td align="left">使用给定的字符串来代表被修剪的文本。</td>
</tr>
</tbody></table>
<h3 id="列表-list-style"><a href="#列表-list-style" class="headerlink" title="列表 list-style"></a>列表 list-style</h3><p>list-style:none列表数字没有了。</p>
<h4 id="list-style-type"><a href="#list-style-type" class="headerlink" title="list-style-type"></a>list-style-type</h4><p>disc<br>circle<br>square<br>decimal<br>decimal-leading-zero<br>lower-roman<br>upper-roman<br>lower-alpha<br>upper-alpha<br>lower-greek<br>lower-latin<br>upper-latin</p>
<h4 id="list-style-position"><a href="#list-style-position" class="headerlink" title="list-style-position"></a>list-style-position</h4><p>outside</p>
<h4 id="list-style-image"><a href="#list-style-image" class="headerlink" title="list-style-image"></a>list-style-image</h4><p>url(“image.png”)</p>
<h3 id="字体font"><a href="#字体font" class="headerlink" title="字体font"></a>字体font</h3><h4 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h4><p>隶书；宋体</p>
<h4 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h4><p>italic部分斜体</p>
<p>oblique所有字体都可以斜体</p>
<h4 id="font-weight粗细"><a href="#font-weight粗细" class="headerlink" title="font-weight粗细"></a>font-weight粗细</h4><p>bold、100-900中的数字</p>
<h4 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h4><p>npx</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h4><p>pointer;pointer小手</p>
<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><p>all .2s;</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="/images%5C1687228184834.png" alt="1687228184834"></p>
<h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><h3 id="height"><a href="#height" class="headerlink" title="height"></a>height</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">background-color:yellow;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">position:absolute;</span><br><span class="line">top:200px;</span><br><span class="line">Left:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置好div容器的大小</p>
<p>若有图片或文字溢出，该怎么办</p>
<ol>
<li>超出dv宽度高度的文字或图片进行隐藏处理</li>
<li>超出dv宽度高度的文字或图片增加滚动条</li>
</ol>
<h3 id="溢出overflow"><a href="#溢出overflow" class="headerlink" title="溢出overflow"></a>溢出overflow</h3><p>visible默认值。内容不会被修剪，会呈现在元素框之外。</p>
<p>hidden超出的部分被隐藏。</p>
<p>scroll不论是否需要，都显示滚动条。</p>
<p>auto按需显示滚动条以便查看其余的内容。</p>
<p>轮廓outline:dashed(虚线) dotted（点状轮廓）solid（实线）double（双线）</p>
<h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><p>border:1px solid black</p>
<h4 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h4><h5 id="border-left"><a href="#border-left" class="headerlink" title="border-left"></a>border-left</h5><h5 id="border-right"><a href="#border-right" class="headerlink" title="border-right"></a>border-right</h5><h5 id="border-top"><a href="#border-top" class="headerlink" title="border-top"></a>border-top</h5><h5 id="border-bottom"><a href="#border-bottom" class="headerlink" title="border-bottom"></a>border-bottom</h5><p>solid，none, double</p>
<h4 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a>border-style</h4><p>上右底左</p>
<p>none: 默认无边框</p>
<p>dotted: 定义一个点线边框</p>
<p>dashed: 定义一个虚线边框</p>
<p>solid: 定义实线边框</p>
<p>double: 定义两个边框。 两个边框的宽度和 border-width 的值相同</p>
<p>groove: 定义3D沟槽边框。效果取决于边框的颜色值</p>
<p>ridge: 定义3D脊边框。效果取决于边框的颜色值</p>
<p>inset:定义一个3D的嵌入边框。效果取决于边框的颜色值</p>
<p>outset: 定义一个3D突出边框。 效果取决于边框的颜色值</p>
<h4 id="border-color"><a href="#border-color" class="headerlink" title="border-color"></a>border-color</h4><h4 id="border-box"><a href="#border-box" class="headerlink" title="border-box:"></a>border-box:</h4><p>已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度</p>
<h4 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h4><p>50% 变成圆形</p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>文字到div的距离</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><h4 id="left"><a href="#left" class="headerlink" title="left"></a>left</h4><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>div到其他部分的距离</p>
<h4 id="margin-top"><a href="#margin-top" class="headerlink" title="margin-top"></a>margin-top</h4><h4 id="margin-left"><a href="#margin-left" class="headerlink" title="margin-left"></a>margin-left</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin:25px 50px 75px 100px;</span><br><span class="line">上边距为25px</span><br><span class="line">右边距为50px</span><br><span class="line">下边距为75px</span><br><span class="line">左边距为100px</span><br><span class="line"></span><br><span class="line">margin:25px 50px 75px;</span><br><span class="line">上边距为25px</span><br><span class="line">左右边距为50px</span><br><span class="line">下边距为75px</span><br><span class="line"></span><br><span class="line">margin:25px 50px;</span><br><span class="line">上下边距为25px</span><br><span class="line">左右边距为50px</span><br><span class="line"></span><br><span class="line">margin:25px;</span><br><span class="line">所有的4个边距都是25px</span><br><span class="line"></span><br><span class="line">auto	设置浏览器边距。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="box"><a href="#box" class="headerlink" title="box"></a>box</h3><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing:"></a>box-sizing:</h4><p>padding的距离由哪产生</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">content-box</td>
<td align="left">默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</td>
</tr>
<tr>
<td align="left">border-box</td>
<td align="left">告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减 去(border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 <strong>注：</strong>border-box 不包含 margin。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">指定 box-sizing 属性的值，应该从父元素继承</td>
</tr>
</tbody></table>
<h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>2px 2px 10px #7d7d7d insert;</p>
<p>灰色，内阴影</p>
<h1 id="脱标流"><a href="#脱标流" class="headerlink" title="脱标流"></a>脱标流</h1><p>文档流：</p>
<p>空白折叠现象（换行就会有空格 不换行就没有）<br>高矮不齐，底边对齐<br>自动换行，一行写满，换行写</p>
<p>脱标流</p>
<h2 id="float："><a href="#float：" class="headerlink" title="float："></a>float：</h2><p>left：向页面最左边左浮动</p>
<p>下面一层忽略float的</p>
<p>right</p>
<p>none</p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>both</p>
<p>黑色部分清除浮动</p>
<p>不再浮动</p>
<p>本来应该被盖在浮动的下面的会另起一行</p>
<p>不会被覆盖了</p>
<p><img src="/images%5C1687243725372.png" alt="1687243725372"></p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#clearDiv:after&#123;</span><br><span class="line">content:&quot;&quot;;</span><br><span class="line">visibility:hidden;</span><br><span class="line">height:0px;</span><br><span class="line">display:block;</span><br><span class="line">clear:·both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=&#x27;clearDiv&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="子元素与父元素"><a href="#子元素与父元素" class="headerlink" title="子元素与父元素"></a>子元素与父元素</h1><p>不指定宽度，默认整个屏幕</p>
<p>不指定高度，默认为0；</p>
<p>指定子元素高度，默认父元素也是那么高。</p>
<p>当子元素为float，则不同步。</p>
<h1 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>不会改变原来的坑，只是网页渲染位置变化</p>
<p>用来微调位置</p>
<h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>绝对坐标定位</p>
<p>默认以网页作为起始点</p>
<p>脱离了标准文档流，对其他元素进行压盖。</p>
<p>应用：轮播图</p>
<p>left到左边的距离；rights到右边的距离；top到上边的距离；bottom到下边的距离</p>
<p>left，right只用一个</p>
<p>top，bottom也只用一个。</p>
<p>如果是父元素是relative或者absolute，那么以父元素为起始点。（子固父相）</p>
<h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>固定定位</p>
<p>脱离标准文档流</p>
<p>应用：返回顶部</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>相对自己原来的或者坐标描述</p>
<h3 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h3><p>向下</p>
<h3 id="left-1"><a href="#left-1" class="headerlink" title="left"></a>left</h3><h3 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h3><p>向上</p>
<h3 id="right"><a href="#right" class="headerlink" title="right"></a>right</h3><h2 id="应用：居中"><a href="#应用：居中" class="headerlink" title="应用：居中"></a>应用：居中</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width:400px;</span><br><span class="line">height:300px;</span><br><span class="line">border:1px solid #000;</span><br><span class="line">margin:40px auto;</span><br><span class="line">position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p&#123;</span><br><span class="line">width:80px;</span><br><span class="line">height:80px;</span><br><span class="line">background-color:Dorange;</span><br><span class="line">position:absolute;</span><br><span class="line">top:50%</span><br><span class="line">margin-top:-40px;</span><br><span class="line">left:50%;</span><br><span class="line">margin-left:-40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>



<h1 id="行内和块级的转换display"><a href="#行内和块级的转换display" class="headerlink" title="行内和块级的转换display"></a>行内和块级的转换display</h1><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>元素转为块级元素</p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>可将元素转为行内元素</p>
<h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>将元素转为行内块</p>
<h1 id="元素的隐藏"><a href="#元素的隐藏" class="headerlink" title="元素的隐藏"></a>元素的隐藏</h1><p>使用display:none;<br>可以将元素隐藏，元素将彻底放弃位置，如同没有写它的标签一样.</p>
<p>使用visibility:hidden;<br>可以也可以将元素隐藏，但是元素不放弃自己的位置。（页面上看到的是白色的方块，方块大小和原来的元素大小一样）</p>
<h1 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h1><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>数值越大，越在顶层</p>
<p>弹性布局</p>
<h2 id="指定flex布局"><a href="#指定flex布局" class="headerlink" title="指定flex布局"></a>指定flex布局</h2><p>display:flex(块级元素)</p>
<p>display:inline-flex(内连块)</p>
<h2 id="flex相关名词"><a href="#flex相关名词" class="headerlink" title="flex相关名词"></a>flex相关名词</h2><p>flex容器里的子元素叫做flex项目</p>
<p>只要有子元素 就可以当作是容器</p>
<p>主轴 交叉轴</p>
<p><img src="/images%5C1687306433055.png" alt="1687306433055"></p>
<p>flex项目沿着主轴方向放置</p>
<h2 id="flex容器的属性"><a href="#flex容器的属性" class="headerlink" title="flex容器的属性"></a>flex容器的属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction:"></a>flex-direction:</h3><p>定义主轴<br>row默认值：默认水平方向从左到右为主轴<br>row-reverse:水平方向从右到左为主轴<br>column:垂直方向从上到下为主轴<br>column-reverse:垂直方向从下到上为主轴</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>定义了如果一条轴线排不下，如何<strong>换行</strong></p>
<p>nowrap默认值直：默认不换行<br>wrap:换行<br>wrap-reverse:不仅换行还改变了默认方向，元素从下到上排列</p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-direction和flex-wrap的简写形式</p>
<p>flex-flow:row wrap</p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>定义了flex项目在主轴上的对齐方式</p>
<p>flex-start(默认值)：默认从行首起始位置开始排列(左对齐)<br>flex-end:从行尾位置开始排列(右对齐)<br>center:居中排列<br>space-between:均匀排列每个元素。首个元素放置于起点，末尾元素放置于终点(均匀排列 首位无间隙)<br>space-around:均匀排列每个元素。每个元素周围分配相同的空间(均匀排列 首位空)</p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>定义了Flex项目在交叉轴上如何对齐</p>
<p>stretch默认值：默认弹性元素被在交叉轴方向被<strong>拉伸</strong>到与容器相同的高度或宽度(占满容器)<br>flex-start:元素向交叉轴起点对齐<br>flex-end:元素向交叉轴终点对齐<br>center:元素在交叉轴居中<br>baseline:所有元素向基线对齐</p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>定义了存在多根主轴线时，Flex项目在交叉轴上如何对齐<br>stretch(默认)：默认拉伸所有行来填满剩余空间<br>flex-start:从起始点开始放置元素<br>flex-end:从终止点开始放置元素<br>center:将元素放置在中点<br>space-between:均匀分布项目。第一项与起始点齐平，最后一项与终止点齐平<br>space-around:均匀分布项目。项目在两端有一半大小的空间</p>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>flex项目的排列顺序</p>
<p>越小越在前面</p>
<p>默认是0</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>放大比例</p>
<p>默认是0，也不会放大，正常排</p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话)（会放大）</p>
<p><img src="/images%5C1687308113459.png" alt="1687308113459"></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>缩小比例0&#x2F;1</p>
<p>如果所有项目的fIex-shrink属性都不为0，当空间不足时，都将等比例缩小</p>
<p>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>在分配多余空间之前，Flex项目占据的主轴大小(main size)</p>
<p>auto</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>fIex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</p>
<p>align-self:</p>
<p>auto（默认值）</p>
<p>flex-start</p>
<p>flex-end </p>
<p>center</p>
<p>stretch </p>
<p>baseline;</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p><img src="/images%5C1687308826154.png" alt="1687308826154"></p>
]]></content>
      <categories>
        <category>css</category>
        <category>网页制作</category>
      </categories>
  </entry>
  <entry>
    <title>从0开始的pytorch环境配置</title>
    <url>/2023/10/15/test/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84pytorch%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="从0开始的pytorch环境配置"><a href="#从0开始的pytorch环境配置" class="headerlink" title="从0开始的pytorch环境配置"></a>从0开始的pytorch环境配置</h1><p>前言：对电脑刷机了，装好了anaconda，但是环境还没配。炼丹必备<span id="more"></span></p>
<h2 id="gpu相关的"><a href="#gpu相关的" class="headerlink" title="gpu相关的"></a>gpu相关的</h2><ol>
<li><p>查看显卡：任务管理器查看是否有英伟达显卡</p>
</li>
<li><p>在官网查看自己的显卡是否支持 CUDA 安装<br>NVIDIA官网地址：<a href="https://developer.nvidia.com/cuda-gpus">https://developer.nvidia.com/cuda-gpus</a></p>
</li>
<li><p>查看自己的显卡驱动版本<br>命令行输入以下命令</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NVIDIA-SMI</span><br></pre></td></tr></table></figure>

<p>如果没有，请将C:\Program Files\NVIDIA Corporation\NVSMI文件夹放置系统路径的path之中</p>
<ol start="4">
<li>升级显卡驱动程序</li>
</ol>
<p>去Nvidia官网地址 <a href="https://links.jianshu.com/go?to=https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a> 按系统版本，选择下载在线升级包, 下载完后，选择<strong>自定义</strong>先升级显卡驱动,如图:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/28789528-198feb5cb4e4e010.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/582/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/28789528-03be5475ba381a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590/format/webp" alt="img"></p>
<ol start="5">
<li>CUDA安装是否成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<h2 id="python环境安装"><a href="#python环境安装" class="headerlink" title="python环境安装"></a>python环境安装</h2><p>1.定义环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n mytorch python==3.9</span><br></pre></td></tr></table></figure>
<p>2.运行环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate mytorch</span><br></pre></td></tr></table></figure>
<p>3.安装<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a><br>pytorch：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install pytorch==2.0.0 torchvision==0.15.0 torchaudio==2.0.0 pytorch-cuda=11.8 -c pytorch -c nvidia -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>4.测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%进入python环境 </span><br><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir(torch)</span><br><span class="line">help(torch.cuda.is_available)</span><br></pre></td></tr></table></figure>
<p>5.jupyter编辑器<br>Anaconda Prompt<br>输入指令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate mytorch</span><br><span class="line">jupyter notebook</span><br><span class="line">#打开jupyter后</span><br><span class="line">import torch</span><br></pre></td></tr></table></figure>
<p>6.查看和删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境的查看</span><br><span class="line">Anaconda Prompt</span><br><span class="line">conda info -e   </span><br><span class="line">环境的删除</span><br><span class="line">conda remove --name yolo5 --all</span><br></pre></td></tr></table></figure>

<p>8.一些镜像源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install tensorflow-cpu==2.3.0 </span><br><span class="line">-i https://mirror.baidu.com/pypi/simple</span><br><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">-i http://pypi.douban.com/simple/</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>Could not find a version that satisfies the requirement<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install &lt;库名&gt;			安装</span><br><span class="line">pip uninstall &lt;库名&gt;		卸载</span><br><span class="line">pip install -U &lt;库名&gt;		更新</span><br><span class="line">pip download &lt;库名&gt;			只下载，不安装</span><br><span class="line">pip show &lt;库名&gt;				展示这个库的信息</span><br><span class="line">pip search &lt;库名&gt;			搜索关键字</span><br><span class="line">pip list				列出安装的库</span><br><span class="line">查看用conda安装的包：</span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>关于乒乓球</title>
    <url>/2023/03/02/test/%E4%B9%92%E4%B9%93%E7%90%83%E8%AE%AD%E7%BB%83%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>本文为博主自己练习乒乓球时的碎碎念，博主十分高兴能够找到一个能够坚持的体育爱好。</p>
<span id="more"></span>

<h1 id="乒乓球训练日记"><a href="#乒乓球训练日记" class="headerlink" title="乒乓球训练日记"></a>乒乓球训练日记</h1><ol>
<li><p>今晚练习乒乓球，这种性格上的改变好像影响了我的乒乓球风格。正手好像是找到了腿和身体和手的协调统一，反手的进步或许源于还原的意识更强烈。通过看视频，我更注重自己身体要稳定，不能散掉。前后的步伐还有待加强。发球的旋转仍然是困难的。</p>
</li>
<li><p>反手的重心要压低一点，要用身体发力的动作。</p>
</li>
<li><p>正手打球的时候太急了一点。</p>
</li>
<li><p>打比赛的时候精神信念，要专注于比赛本身，敢于发力，精神集中。不要觉得自己很弱不敢打，对待好每个球，要有一些自己的判断，不能瞎打。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>乒乓球</category>
      </categories>
      <tags>
        <tag>乒乓球</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/29/test/hello-world/</url>
    <content><![CDATA[<p>Hello World！</p>
<p>这里是老约翰的世界。欢迎。</p>
]]></content>
  </entry>
  <entry>
    <title>数据库重点内容</title>
    <url>/2023/03/24/test/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>交互式SQL和嵌入式SQL</p>
<p>独立使用SQL语言进行数据库操作时，其使用方法称为交互式SQL，独立使用SQL语言进行数据库操作时，其使用方法称为交互式SQL</p>
<p>当一个程序既要访问数据库，又要处理数据时，把SQL语言嵌入程序设计语言即宿主语言中，将SQL语言访问数据库的功能和宿主语言的数据处理功能相结合，是目前解决该问题的最有效途径。</p>
<span id="more"></span>

<h1 id="一、数据-相关概念"><a href="#一、数据-相关概念" class="headerlink" title="一、数据..相关概念"></a>一、数据..相关概念</h1><p>数据库中储存的是<strong>数据与数据的联系</strong></p>
<p><strong>长期储存</strong>在计算机内、<strong>有组织的</strong>、<strong>可共享的</strong>数据集合</p>
<h2 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h2><p>社交网络数据库<br>电子商务平台数据库<br>企业信息数据库<br>通讯数据库</p>
<p>数据库中的数据可以共享</p>
<p>数据库减少了数据冗余</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数值、图形、文本、音频…..</p>
<h2 id="数据-DATA-储存方式"><a href="#数据-DATA-储存方式" class="headerlink" title="数据(DATA)储存方式"></a>数据(DATA)储存方式</h2><p>写在纸上的，存在excel表格的…</p>
<ul>
<li>本节课的数据库（DB）特指长期储存在计算机内、有组织的、可共享的数据集合。</li>
</ul>
<h2 id="数据库管理系统（DBMS）-Mysql"><a href="#数据库管理系统（DBMS）-Mysql" class="headerlink" title="数据库管理系统（DBMS）- Mysql"></a>数据库管理系统（DBMS）- Mysql</h2><p>SQL 语言集数据定义 、数据查询  、数据操纵、数据控制功能于一体。 </p>
<ul>
<li>数据库管理系统<strong>是位于用户与操作系统之间</strong>的一层数据管理软件</li>
<li>目标：科学地组织和存储数据、高效地获取和维护数据</li>
<li>位于用户应用与操作系统之间的一层数据管理软件</li>
<li>属于基础软件，是一个大型复杂的软件系统。</li>
<li>一组系统软件，而不是一组应用软件。</li>
</ul>
<h3 id="数据定义DDL"><a href="#数据定义DDL" class="headerlink" title="数据定义DDL"></a>数据定义DDL</h3><p>提供数据定义语言(DDL)，用于定义数据库中的数据对象</p>
<p>语言：DDL</p>
<h3 id="数据操作-x2F-数据操控DML"><a href="#数据操作-x2F-数据操控DML" class="headerlink" title="数据操作&#x2F;数据操控DML"></a>数据操作&#x2F;数据操控DML</h3><p>提供数据操纵语言(DML)，用于操纵数据实现对数据库的基本操作(查询、插入、删除和修改)</p>
<p><strong>增删改查</strong></p>
<p>语言：DML</p>
<h3 id="数据库控制"><a href="#数据库控制" class="headerlink" title="数据库控制"></a>数据库控制</h3><p>语言：</p>
<h3 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h3><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>对外连接</p>
<h2 id="数据库管理员（DBA）"><a href="#数据库管理员（DBA）" class="headerlink" title="数据库管理员（DBA）"></a>数据库管理员（DBA）</h2><p>负责全面管理和控制数据库系统，是数据库系统中最重要的人员。<br>职责（我们的学习目标）：</p>
<ul>
<li>设计和定义数据库系统</li>
<li>帮助最终用户使用数据库系统</li>
<li>监督与控制数据库系统的使用和运行</li>
<li>改进和重组数据库系统</li>
<li>调优数据库系统的性能</li>
<li>转储和恢复数据库</li>
<li>重构数据库</li>
</ul>
<h2 id="数据库系统（DBS）"><a href="#数据库系统（DBS）" class="headerlink" title="数据库系统（DBS）"></a>数据库系统（DBS）</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>①数据<strong>结构化</strong><br>②数据的共享性高，<strong>冗余度低</strong>，且容易扩充。<br>③数据<strong>独立性</strong>高(物理独立性（应用程序与物理存储相互独立，数据的物理存储改变应用程序不改变),（逻辑独立性人应用程序与逻辑结构相互独立，数据的逻辑结构改变应用程序不改变）<br>④数据由数据库管理系统<strong>统一管理和控制</strong></p>
<p>在DBS中，DBMS调用了OS的功能。</p>
<p>数据共享，数据独立性高，数据完整性，减少了数据冗余。</p>
<p>应用数据库技术的主要目的是为了共享数据问题。</p>
<p>在计算机系统中引入数据库后的系统构成</p>
<p>数据库系统的构成：</p>
<ul>
<li>数据库</li>
<li>数据库管理系统</li>
<li>应用系统（及其开发工具）</li>
<li>相关人员（数据库管理员、应用系统开发人员、用户）</li>
</ul>
<p>概括： 硬件、软件(DBMS运行的操作系统和本身)、数据库、用户</p>
<h2 id="应用系统"><a href="#应用系统" class="headerlink" title="应用系统"></a>应用系统</h2><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h2 id="应用开发软件"><a href="#应用开发软件" class="headerlink" title="应用开发软件"></a>应用开发软件</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>数据库中，产生数据不一致的根本原因是数据冗余</p>
<p><strong>主要原因是事务的隔离性在并发中遭到了破坏</strong></p>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>数据模型是数据库系统的<strong>核心和基础</strong></p>
<p>在数据库中用数据模型这个工具来抽象、表示和处理现实世界中的数据和信息。通俗地讲数据模型就是现实世界的模拟。例如：地图、航模飞机。</p>
<p>数据模型应满足三方面要求<br>能比较真实地模拟现实世界<br>容易为人所理解<br>便于在计算机上实现。</p>
<p>将E-R模型转换成关系模型，属于数据库的逻辑设计。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>现实世界 –&gt; 概念模型 –&gt; 逻辑模型 –&gt; 物理模型 –计算机中数据</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>信息模型</p>
<p>它是<strong>面向用户的模型</strong>，是现实世界到机器世界的一个中间层次。其基本特征是按用户观点对信息进行建模，<strong>与具体DBMS无关。</strong></p>
<p>世界是由一组称作实体的基本对象和这些对象之间的联系构成。</p>
<h4 id="E-R模型："><a href="#E-R模型：" class="headerlink" title="E-R模型："></a>E-R模型：</h4><p>独立于<strong>计算机系统</strong>的模型</p>
<p>实体－联系方法<br>（1）<strong>实体</strong>（Entity）。实体是指客观存在并可相互区别的事物。实体可以是人、事或物，也可以是抽象的概念。如一件商品、一个客户、一份订单等都是实体。</p>
<p>关系模型中实现实体间 N：M 联系是通过增加一个<strong>关系实现</strong>。</p>
<p>（2）<strong>属性</strong>（Attribute）。实体通常有若干特征，每个特征称为实体的一个属性。属性刻画了实体在某方面的特性。例如，商品实体的属性可以有商品编号、商品类别、商品名称、生产商等。<br>（3）<strong>联系</strong>（Relationship）。现实世界中事物之间的联系反映在E-R模型中就是<strong>实体间的联系</strong>。例如，订单就是客户和商品之间的联系。</p>
<h5 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h5><p>实体用矩形框表示，属性用椭圆形框表示，联系用菱形框表示,实体与属性与联系之间用无向直线连接。</p>
<h4 id="概念模型的用途"><a href="#概念模型的用途" class="headerlink" title="概念模型的用途"></a>概念模型的用途</h4><p>概念模型用于信息世界的建模<br>是现实世界到机器世界的一个中间层次<br>是数据库设计的有力工具<br>数据库设计人员和用户之间进行交流的语言</p>
<h4 id="对概念模型的基本要求"><a href="#对概念模型的基本要求" class="headerlink" title="对概念模型的基本要求"></a>对概念模型的基本要求</h4><p>较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识<br>简单、清晰、易于用户理解。</p>
<h4 id="转表"><a href="#转表" class="headerlink" title="转表"></a>转表</h4><p>如果两个实体之间具有 m：n 联系，则将它们转换为关系模型的结果是3个表。</p>
<h3 id="逻辑模型（数据模型）"><a href="#逻辑模型（数据模型）" class="headerlink" title="逻辑模型（数据模型）"></a>逻辑模型（数据模型）</h3><p>大多数时候就直接称为数据模型</p>
<p>由DBMS支持的</p>
<h4 id="三要素1：数据结构"><a href="#三要素1：数据结构" class="headerlink" title="三要素1：数据结构"></a>三要素1：数据结构</h4><p>静态特性，数据本身以及数据之间的联系。<br>刻画数据模型性质的重要方面。<br>通常采用数据结构的类型来命名数据模型。</p>
<h5 id="关系模型（主流）"><a href="#关系模型（主流）" class="headerlink" title="关系模型（主流）"></a>关系模型（主流）</h5><p>基本的数据结构是表格，关系模型使用<strong>二维表</strong>来表示实体及其联系。<br>关系模型的数据操作主要包括查询和更新。关系数据操作具有两个显著特点：一是关系操作是集合操作，即操作的对象和结果均为集合；二是关系模型将操作中的存取路径向用户屏蔽起来，用户只要说明做什么，而不必指出怎样做。</p>
<h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>网状（可以多根）（多个父亲）</p>
<p>允许两个结点间有多种联系（复合联系）</p>
<h5 id="层次模型-树状"><a href="#层次模型-树状" class="headerlink" title="层次模型-树状"></a>层次模型-树状</h5><p>（一个根）（一个联系）</p>
<h5 id="面向对象模型-Object-Oriented-Model）"><a href="#面向对象模型-Object-Oriented-Model）" class="headerlink" title="面向对象模型*(Object Oriented Model）"></a>面向对象模型*(Object Oriented Model）</h5><h5 id="对象关系模型-Object-Relational-Model"><a href="#对象关系模型-Object-Relational-Model" class="headerlink" title="对象关系模型*(Object Relational Model)"></a>对象关系模型*(Object Relational Model)</h5><h4 id="三要素2：数据操作"><a href="#三要素2：数据操作" class="headerlink" title="三要素2：数据操作"></a>三要素2：数据操作</h4><p>数据操作指对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则，它是对数据库动态特性的描述。<br>数据库中的数据操作主要分为查询、更新两大类，其中数据更新主要是指对数据记录的增、删、改。<br>数据模型需要定义这些操作的语义、操作符号、操作规则及实现操作的相关语句。 </p>
<p>动态特征，允许执行的操作的集合，包括操作及操作规则。一般有检索、更新(插入、副除、修改)操作。</p>
<h4 id="三要素3：数据完整性约束"><a href="#三要素3：数据完整性约束" class="headerlink" title="三要素3：数据完整性约束"></a>三要素3：数据完整性约束</h4><p>完整性约束是数据的一组完整性规则的集合。<br>完整性规则是给定的数据模型中数据及其联系所具有的制约和存储规则，用以限定符合数据模型的数据库状态以及状态的变化，保证数据的正确、有效、相容。 </p>
<p>是完整性规则的集合，规定数据库状态及状态变化所应满足的条件。</p>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>在数据库系统阶段，数据和程序之间具有较高的独立性。</p>
<h1 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h1><p>目的：提高数据和程序的独立性。</p>
<ul>
<li>系统模式的概念:<ul>
<li>模式（Schema）<br>  是对数据库逻辑结构和特征的描述是型的描述，<strong>不涉及具体值</strong>模式是相对稳定的</li>
<li>实例（Instance）<br>  数据库某一时刻的状态——<strong>模式的一个具体值</strong>同一个模式可以有很多实例,实例随数据库中的数据的更新而变动</li>
</ul>
</li>
</ul>
<h2 id="三级模式：（外模式、模式、内模式）"><a href="#三级模式：（外模式、模式、内模式）" class="headerlink" title="三级模式：（外模式、模式、内模式）"></a>三级模式：（外模式、模式、内模式）</h2><p>这是数据库开发人员的角度，是内部结构。三级模式是对数据的三个抽象级别</p>
<h3 id="外模式（视图）-子模式）（用户模式-："><a href="#外模式（视图）-子模式）（用户模式-：" class="headerlink" title="外模式（视图）(子模式）（用户模式)："></a>外模式（视图）(子模式）（用户模式)：</h3><p>视图是存放在数据库的表，为了安全。视图可以有多个，代表<strong>外模式也可以有多个</strong>。</p>
<p>数据库用户使用的<u>局部数据的逻辑结构和特征的描述</u></p>
<p>外模式通常是<strong>模式的子集</strong>、一个模式可以有多个外模式反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求。每个用户只能看见和访问所对应的外模式中的数据，简化<strong>用户视图</strong>。</p>
<p><strong>单个用户使用的数据视图的描述称为“外模式”。</strong></p>
<h3 id="模式（基本表）-逻辑模式-："><a href="#模式（基本表）-逻辑模式-：" class="headerlink" title="模式（基本表）(逻辑模式)："></a>模式（基本表）(逻辑模式)：</h3><p>一个数据库只有<strong>一个模式</strong></p>
<p>模式是数据库系统模式结构的中心</p>
<p>数据库全体数据的逻辑结构和特征的描述，所有用户的公共数据视图。</p>
<p>这里的基本表并不是指你创建的表，而是本身存放在数据库的基本表，它们构成了一套逻辑结构来代表模式。</p>
<p>与数据的物理存储细节和硬件环境无关、与具体的应用程序、开发工具及高级程序设计语言无关。</p>
<h3 id="内模式（存储模式）："><a href="#内模式（存储模式）：" class="headerlink" title="内模式（存储模式）："></a>内模式（存储模式）：</h3><p><strong>一个数据库只有一个内模式</strong></p>
<ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式记录的存储方式<br>  （例如，顺序存储，堆存储，Cluste按hash方法存储等）<ul>
<li><p>索引的组织方式（B+树，Bitmap，Hash）</p>
</li>
<li><p>数据是否压缩存储数据是否加密</p>
</li>
<li><p>数据存储记录结构的规定—如定长&#x2F;变长，记录是否可以跨页存放等</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>DBMS提供三种模式的描述语言（DDL）来严格定义三种模式。</p>
<h2 id="两级映象：（外模式-x2F-模式，模式-x2F-内模式映象-）"><a href="#两级映象：（外模式-x2F-模式，模式-x2F-内模式映象-）" class="headerlink" title="两级映象：（外模式&#x2F;模式，模式&#x2F;内模式映象 ）"></a>两级映象：（外模式&#x2F;模式，模式&#x2F;内模式映象 ）</h2><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p>
<p>引入知识点：<strong>映象，这</strong>是一种对应规则，说明映象双方如何进行转换。</p>
<h3 id="1-外模式-x2F-模式映象"><a href="#1-外模式-x2F-模式映象" class="headerlink" title="1.外模式&#x2F;模式映象"></a><strong>1.外模式&#x2F;模式映象</strong></h3><p>首先我们要知道这是定义在外模式描述中</p>
<p>官方的概念是：把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系起来，保证逻辑独立性。</p>
<p>当模式改变时，只要对外模式&#x2F;模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的逻辑独立性，也就是数据的<strong>逻辑独立性</strong>。</p>
<p>个人理解是，我创建了一张表，有年龄这一字段，是int类型，我更改了类型为str类型，没有报错，那么对于我在这张表上之前输入的数据，不会改变，视图也不会改变</p>
<h3 id="模式-x2F-内模式映象"><a href="#模式-x2F-内模式映象" class="headerlink" title="模式&#x2F;内模式映象"></a><strong>模式&#x2F;内模式映象</strong></h3><p>映像是唯一的</p>
<p>首先我们要知道这是定义在模式描述中</p>
<p>官方概念:把描述全局逻辑结构的模式与描述物理结构的内模式联系起来,保证<strong>物理独立性</strong>。</p>
<p>当内模式改变时，比如存储设备或存储方式有所改变，只要模式&#x2F;内模式映象做相应的改变，使模式保持不变，则应用程式保持不变。</p>
<h1 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>所有实体及实体之间联系的关系的集合构成一个关系数据库</p>
<p><u>所有关系的集合</u></p>
<p>关系数据库模式是关系模式的集合。</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模型，只包含单一的数据结构——关系</p>
<p>实体以及实体间的各种联系均用单一的结构类型——关系来表示</p>
<p>关系模型中的数据的逻辑结构是一张扁平的二维表</p>
<p>建立在集合代数的理论基础上</p>
<p>关系模式通常可以简记为<br>R(U,D,DOM,F)</p>
<p>U:属性名集合</p>
<p>D：U中属性来自的域</p>
<p>DOM：属性向域的映像集合</p>
<p>F:数据依赖</p>
<p>其中，R为关系名，A1，A2，…，An属性名</p>
<p>完整性约束</p>
<p>关系的<strong>目</strong>：列数。</p>
<h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>一组具有相同数据类型的值的集合，反映在二维表中则是某一列的单元格的值的取值范围。</p>
<p>{‘男’，‘女’}&#x2F;介于2007年7月1日到2008年2月29日之间的日期</p>
<h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>一种集合运算</p>
<p>$$D _ { 1 } \times D _ { 2 } \times \cdots D _ { n } &#x3D; { ( d _ { 1 } , d _ { 2 } , \cdots d _ { n } ) | d _ { i } ∈ D _ { i }}$$</p>
<p>所有域的所有取值的一个组合<br>不能重复</p>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>笛卡尔积中每一个元素</p>
<p>$( d _ { 1 } , d _ { 2 } , \cdots d _ { n })$</p>
<h4 id="分量"><a href="#分量" class="headerlink" title="分量"></a>分量</h4><p>$( d _ { 1 } , d _ { 2 } , \cdots d _ { n })$的$d_{i}$</p>
<h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><p>多少个元组</p>
<p>D1&#x3D;{张清玫，刘逸}，基数：2</p>
<p>D2&#x3D;{计算机专业，信息专业}，基数：2</p>
<p>D3&#x3D;{李勇，刘晨，王敏}，基数：3</p>
<p>D1×D2×D3的基数2×2×3&#x3D;12</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>D1×D2×…Dn的子集叫作在域D1,D2,…Dn上的关系，表示为：R(D1,D2,…Dn)</p>
<p>R为关系名，n为关系的目或度</p>
<h4 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h4><p>关系中的每个元素是关系中的元组，通常用t表示。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>关系中不同列可以对应相同的域，但必须对每列起一个名字，称为属性（Attribute）</p>
<p>属性的取值范围为域。</p>
<p>n目关系必有n个属性。</p>
<h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><p>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</p>
<p>最简单：有且只有一个属性能唯一标识元组，即候选码只包含一个属性。<br>最极端：所有属性组合起来才能唯一标识元组，即候选码包含全部属性，称为全码（All-key）</p>
<p>候选码的各个属性称为主属性（Primeattribute）<br>不包含在任何侯选码中的属性称为非主(码)属性（Non-key attribute）</p>
<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><p>判断候选码<br><strong>已知:</strong> AB-&gt;C;<br><strong>自反</strong>：AB-&gt;AB；<br><strong>合并</strong>：AB-&gt;ABC;</p>
<p>已知: B-&gt;D;<br><strong>增广</strong>：AB-&gt;AD;</p>
<p>已知: A-&gt;B,B-&gt;C<br><strong>传递</strong>：A-&gt;C</p>
<h5 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h5><p>若一个关系有多个候选码，则选定其中一个为主控使用者，称为主码（Primary key）</p>
<h4 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h4><p>二维表	</p>
<h4 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h4><h5 id="基本关系（又称为基本表或基表）"><a href="#基本关系（又称为基本表或基表）" class="headerlink" title="基本关系（又称为基本表或基表）"></a>基本关系（又称为基本表或基表）</h5><p>实际存在的表，是实际存储数据的逻辑表示</p>
<h5 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h5><p>查询结果对应的表，虚表</p>
<h5 id="视图表"><a href="#视图表" class="headerlink" title="视图表"></a>视图表</h5><p>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>列是同质的（Homogeneous）：每一列中的分量是同一类型的数据，来自同一个域。</p>
<p>不同的列可出自同一个域：每一列称为一个属性。不同的属性要给予不同的属性名。</p>
<p>列的顺序无所谓</p>
<p>行的顺序无所谓</p>
<p>任意两个元组的码不能相同：码的唯一性</p>
<p>分量必须取原子值：一个属性分为两个部分（[导师]–&gt;[导师1]+[导师2]）是不被允许的。</p>
<h3 id="关系模式与关系"><a href="#关系模式与关系" class="headerlink" title="关系模式与关系"></a>关系模式与关系</h3><p>关系模式是静态的、稳定的（属性名集合）<br>关系是动态的、随时间不断变化的（整张表）</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>查询<br>选择（找到）、投影（选出其中的某些列）、连接、除、并、差、交、笛卡尔积等<br>数据更新<br>插入、删除、修改</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><p>具有关系代数和关系演算双重特点的语言–SQL（StructuredQueryLanguage）</p>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><p> 关系的三类完整性约束,实体完整性和参照完整性适用于任何关系数据库系统,是关系模型必须满足的完整性约束条件，应该由关系系统自动支持</p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>所有主属性不能取空值</p>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>关系的引用</p>
<h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><p><strong>外码</strong>（外键）（ForeignKey）<br>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码。<br>基本关系R称为参照关系(Referencing Relation)</p>
<p>基本关系S称为被参照关系(Referenced Relation)或目标关系(Target Relation)</p>
<p><strong>外码的特点</strong><br>目标关系S的主码K_s和参照关系的外码F必须定义在同一个（或一组）域上。</p>
<p>取下面两类值：<br>（1）空值<br>表示尚未分配。<br>（2）非空值<br>必须一一对应</p>
<p><u>外码并不一定要与相应的主码同名</u>，但当外码与相应的主码属于不同关系时，往往取相同的名字便于识别。</p>
<ul>
<li>学生、课程、学生与课程之间的多对多联系</li>
</ul>
<p>学生（学号，姓名，性别，专业号，年龄）【被参照关系】</p>
<p>课程（课程号，课程名，学分）【被参照关系】</p>
<p>选修（学号，课程号，成绩）【参照关系】中学号和课程号分别是外码，合在一起作为选秀的主码。</p>
<p>选修（学号，课程号，成绩）中学号和课程号分别是外码，合在一起作为选秀的主码。</p>
<ul>
<li>学生实体及其内部的联系</li>
</ul>
<p>学生（学号，姓名，性别，专业号，年龄，班长）中，班长是外码。【既是被参照关系也是参照关系】</p>
<h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><p>用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的要求。</p>
<h4 id="两个不变性"><a href="#两个不变性" class="headerlink" title="两个不变性"></a>两个不变性</h4><p>实体完整性<br>参照完整性</p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>五种基本关系代数：包括<u>并 (∪)、差 (-)、广义笛卡尔积 (×)、投影 (π)和选择 (σ)</u>，其他运算的功能都可以由这五种基本运算来实现。</p>
<p>关系代数运算是以集合运算为基础的运算。</p>
<p>关系代数运算的三大要素</p>
<p>运算对象：关系</p>
<p>运算结果：关系</p>
<p>运算符：四类</p>
<p><img src="/images%5C1664849284855.png" alt="1664849284855"></p>
<p>R和S<br>具有相同的目n（即两个关系都有n个属性）<br>相应的属性取自同一个域<br>t是元组变量，t∈R表示t是R的一个元组</p>
<h4 id="并"><a href="#并" class="headerlink" title="并"></a>并</h4><p>R∪S&#x3D;{t|t∈R∨t∈S}</p>
<p>仍为n目关系，由属于R或属于S的元组组成</p>
<h4 id="差"><a href="#差" class="headerlink" title="差"></a>差</h4><p>R—S&#x3D;{t|t∈R∧不属于S}</p>
<p>仍为n目关系，由属于R而不属于S的所有元组组成</p>
<p>关系代数表达式R－（R－S），表达的是<strong>R∩S</strong>。</p>
<h4 id="交"><a href="#交" class="headerlink" title="交"></a>交</h4><p>假设2：<br>R是n目关系，包含k1个元组<br>S是m目关系，包含k2个元组</p>
<h4 id="笛卡尔积-1"><a href="#笛卡尔积-1" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>列：（n+m）列的元组的集合。<br>元组的前n列是关系R的一个元组；<br>后m列是关系S的一个元组。行：k1×k2个元组</p>
<p><img src="/images%5C1664849671016.png" alt="1664849671016"></p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h4><p><img src="/images%5C1664850275837.png" alt="1664850275837"></p>
<h3 id="专门"><a href="#专门" class="headerlink" title="专门"></a>专门</h3><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>选择又称为限制（Restriction）</p>
<p>$σ_F (R)$</p>
<p>F：选择条件，是一个逻辑表达式，取“真”或“假”值，其基本形式为：XθY<br>θ：比较运算符（＞，≥，＜，≤，＝或&lt;&gt;）</p>
<p>$σ_{5 &#x3D; ‘is’} $意思为第五个属性</p>
<p>$σ_{5&lt;20} $第五个属性小于20</p>
<p>选择行</p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>从R中选择出若干属性列组成新的关系，是从列的角度进行运算。  </p>
<p>$π_A(R)$</p>
<p>查询学生关系Student中都有哪些系</p>
<p>$π_{Sdep}(Student)$</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>关系代数中的联接操作是由<strong>选择和笛卡尔积</strong>操作组合而成</p>
<p>连接也称为θ连接<br>从两个关系的笛卡尔积中选取属性间满足一定条件的元组。</p>
<p><img src="/images%5C1664851967414.png" alt="1664851967414"></p>
<p>从两个关系的<strong>笛卡尔积中选取</strong>属性间满足一定条件的元组。</p>
<p><img src="/images%5C1664852589235.png" alt="1664852589235"></p>
<h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p><img src="/images%5C1664852599794.png" alt="1664852599794"></p>
<h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>自然连接是一种特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组，在结果中把重复的属性列去掉</p>
<p><img src="/images%5C1664852609084.png" alt="1664852609084"></p>
<p>悬浮元组：两个关系R和S在自然连接时，关系R和S中被舍弃的元组称为悬浮元组。</p>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>用途：将不满足条件的悬浮元组也加入到输出结果之中。</p>
<p>外连接：如果把<strong>舍弃的元组也保存在结果关系中</strong>，而在其他属性上填空值(Null)，这种连接就叫做外连接（OUTER JOIN）。</p>
<h6 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h6><p>如果只把<strong>左边</strong>关系R中要舍弃的元组<strong>保留</strong>就叫做左外连接(LEFT OUTER JOIN或LEFT JOIN)</p>
<h6 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h6><p>如果只把<strong>右边</strong>关系S中要舍弃的元组<strong>保留</strong>就叫做右外连接(RIGHT OUTER JOIN或RIGHT JOIN)</p>
<h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><p>同时从行和列角度进行运算<br>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作<br>$$R \div S &#x3D; { t _ { r } [ X ] | t _ { r } ∈ R ∧ \pi _ { Y } ( S ) ⊆ Y _ { x } }$$</p>
<p><img src="/images%5C1664931126030.png" alt="1664931126030"></p>
<p><img src="/images%5C1664931138080.png" alt="1664931138080"></p>
<p><img src="/images%5C1664932633268.png" alt="1664932633268"></p>
<p><img src="/images%5C1664932665351.png" alt="1664932665351"></p>
<p>ABC&#x2F;BCD &#x3D; A(BC共有的部分的A)</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><h3 id="B-Tree数据结构"><a href="#B-Tree数据结构" class="headerlink" title="B-Tree数据结构"></a>B-Tree数据结构</h3><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>索引（Index）是一种特殊的数据结构，其作用相当于一本书的目录，可以用来快速查询数据库表中的特定记录。</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>1）从<strong>物理结构</strong>上可以分为聚集索引和非聚集索引两类：</p>
<ul>
<li><strong>聚簇索引</strong>指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的<strong>主键索引</strong>；</li>
<li><strong>非聚簇索引</strong>的逻辑顺序则与数据行的物理顺序不一致。</li>
</ul>
<p>2）从<strong>应用</strong>上可以划分为一下几类：</p>
<ul>
<li><strong>普通索引</strong>：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 <code>ALTER TABLE table_name ADD INDEX index_name (column)</code> 创建；</li>
<li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。通过 <code>ALTER TABLE table_name ADD UNIQUE index_name (column)</code> 创建；</li>
<li><strong>主键索引</strong>：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li>
<li><strong>组合索引</strong>：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li>
<li><strong>全文索引</strong>：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li>
</ul>
<h2 id="索引B-Tree和B-Tree"><a href="#索引B-Tree和B-Tree" class="headerlink" title="索引B-Tree和B+Tree"></a>索引B-Tree和B+Tree</h2><h2 id="B-Tree与hash索引的比较"><a href="#B-Tree与hash索引的比较" class="headerlink" title="B-Tree与hash索引的比较"></a>B-Tree与hash索引的比较</h2><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h2 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h2><h1 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h1><p>一个关系内部属性与属性之间的约束关系叫做数据依赖。</p>
<h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</p>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>设 R 为任一给定关系，如果对于 R 中属性 X 的每一个值，R 中的属性 Y 只有唯一值与之对应，则称 X 函数决定 Y 或称 Y 函数依赖于 X ，记作 X—&gt;Y。其中，X 称为决定因素。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="平凡函数依赖"><a href="#平凡函数依赖" class="headerlink" title="平凡函数依赖"></a>平凡函数依赖</h4><h4 id="非平凡函数依赖"><a href="#非平凡函数依赖" class="headerlink" title="非平凡函数依赖"></a>非平凡函数依赖</h4><h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><ul>
<li>如果存在 X 属性集（注意是集合，说明是联合主键）决定 唯一的 Y ，且 X 中的<strong>任一子集都不能决定</strong>唯一的 Y，则 Y 完全依赖于 X。</li>
<li>例如：学生数学成绩完全由该学生的学号和数学课决定，所以数学课成绩完全依赖于（学号，数学课）</li>
</ul>
<h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>多属性</p>
<ul>
<li>X 的属性集中任一子集可以决定唯一的 Y</li>
<li>例如：学生学号和姓名可以决定唯一的学生，但是学生号也可以决定唯一的学生</li>
</ul>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><ul>
<li><p>设 R 为任一给定关系， X Y Z 为其不同的属性子集，若 X —&gt; Y, Y 不决定 X 且 Y —&gt;Z，则有 X —&gt;Z，称为 Z 传递函数依赖于 X</p>
</li>
<li><p>例如：书的出版编号是唯一，版权归出版社所有，所以只能由该出版社出版。所以存在函数依赖：书出版编号—&gt;出版社名，出版社名—&gt;出版社地址，但是出版社名不能决定唯一的出版书编号，则有出版社地址传递函数依赖于出版书编号</p>
</li>
</ul>
<h4 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h4><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="投影性"><a href="#投影性" class="headerlink" title="投影性"></a>投影性</h4><h4 id="扩张性"><a href="#扩张性" class="headerlink" title="扩张性"></a>扩张性</h4><h4 id="合并性"><a href="#合并性" class="headerlink" title="合并性"></a>合并性</h4><h4 id="分解性"><a href="#分解性" class="headerlink" title="分解性"></a>分解性</h4><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><h3 id="候选码-1"><a href="#候选码-1" class="headerlink" title="候选码"></a>候选码</h3><p><strong>完全函数依赖</strong> U 则是候选码，一般键叫做候选键。</p>
<h3 id="超码"><a href="#超码" class="headerlink" title="超码"></a>超码</h3><p>部分函数依赖 U 则是超码，候选码是最小的超码。</p>
<h3 id="全码"><a href="#全码" class="headerlink" title="全码"></a>全码</h3><p>整个属性集是候选码 则是全码</p>
<h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><p>不是自己的关系模式R的候选码，但是是另一个关系模式的候选码</p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式是符合某一种级别的关系模式的集合 。<strong>范式</strong>是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>范式</td>
<td>范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。</td>
<td>查询时通常需要多表关联查询，更难进行索引优化</td>
</tr>
<tr>
<td>反范式</td>
<td>反范式的过程就是通过冗余数据来提高查询性能，可以减少表关联和更好进行索引优化</td>
<td>存在大量冗余数据，并且数据的维护成本更高</td>
</tr>
</tbody></table>
<h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。 </p>
<p>为了确保原子性的，也就是存储的数据具备不可再分性。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>2NF：在1NF基础上，数据表中每一条记录可唯一标识，所有非主键字段必须<strong>完全依赖</strong>于<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E9%94%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22475125865%22%7D">主键</a>，不能部分依赖于主键 ，<strong>消除部分函数依赖</strong>。</p>
<p>2NF设计原则：一张表只表达一个意思, 对于部分依赖于主键的字段，将这 部分字段 与 依赖的部分主键 抽取出来建立新表。</p>
<p>表中的每一列都要和主键有关。<strong>而不能只与主键的某一部分相关</strong>，不存在非主属性对码的部分函数依赖。</p>
<p>采用投影分解法将1NF变成2NF.</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>3NF：在2NF基础上，非主属性之间不能相互依赖，非主属性之间相互独立，<strong>消除传递依赖</strong>。不存在非主属性对码的传递函数依赖。</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>不存在主属性的对码的传递函数依赖</p>
<h2 id="根据范式分解"><a href="#根据范式分解" class="headerlink" title="根据范式分解"></a>根据范式分解</h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="更新异常"><a href="#更新异常" class="headerlink" title="更新异常"></a>更新异常</h3><p>更新复杂</p>
<h3 id="插入异常"><a href="#插入异常" class="headerlink" title="插入异常"></a>插入异常</h3><p>应该插入的未插入</p>
<h3 id="删除异常"><a href="#删除异常" class="headerlink" title="删除异常"></a>删除异常</h3><p>不该被删除的被删除</p>
<h3 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h3><p>出现各种问题的原因<br>关系模式属性列之间存在混乱的依赖关系</p>
<p>解决方法<br>通过分解关系模式来消除其中不合适的数据依赖。</p>
<h2 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a>安全控制</h2><h3 id="账户控制"><a href="#账户控制" class="headerlink" title="账户控制"></a>账户控制</h3><h3 id="日志控制"><a href="#日志控制" class="headerlink" title="日志控制"></a>日志控制</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一组要执行的SQL,要么都执行成功，要么都不执行</p>
<p>事务是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<p>在MlySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务；</p>
<p>事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。<br>事务用来管理insert,update,delete语句。</p>
<p><strong>事务结束</strong>指的是事务提交成功(COMMIT)&#x2F;事务回滚(ROLLBACK)</p>
<h4 id="事务使用场景"><a href="#事务使用场景" class="headerlink" title="事务使用场景"></a>事务使用场景</h4><p>开启事务后再写数据来保证正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br><span class="line">COMMIT #事务正常结束</span><br><span class="line">ROLLBACK #事务异常终止，回滚到开始前状态（要么都执行要不都不执行）</span><br><span class="line"></span><br><span class="line">---1</span><br><span class="line">BEGIN</span><br><span class="line">READ A</span><br><span class="line">A=A-M</span><br><span class="line">IF A&lt;0</span><br><span class="line">ROLLBACK</span><br><span class="line">IF A&gt;=0</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><h5 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h5><h5 id="不能重复读"><a href="#不能重复读" class="headerlink" title="不能重复读"></a>不能重复读</h5><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><h4 id="特性ACID"><a href="#特性ACID" class="headerlink" title="特性ACID"></a>特性ACID</h4><h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p>最小单位，逻辑单位，要么都执行要不都不执行</p>
<h5 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h5><p>从一个一致性到另一个一致性的状态</p>
<h5 id="隔离性isolation"><a href="#隔离性isolation" class="headerlink" title="隔离性isolation"></a>隔离性isolation</h5><p>一个事务的执行不能被其他事务干扰</p>
<h4 id="隔离级别-按照级别排序"><a href="#隔离级别-按照级别排序" class="headerlink" title="隔离级别(按照级别排序)"></a>隔离级别(按照级别排序)</h4><h5 id="1-读未提交：read-uncommitted"><a href="#1-读未提交：read-uncommitted" class="headerlink" title="- (1)读未提交：read uncommitted"></a>- (1)<strong>读未提交</strong>：read uncommitted</h5><p>提供了事务间最小限度的隔离。</p>
<p><strong>实现原理</strong><br><u>读不加锁，写加排它锁（X锁）</u><br><u>直接读磁盘中的数据</u></p>
<p>  事物A和事物B,，事物A未提交的数据，事物B可以读取到<br>  这里读取到的数据叫做<strong>“脏数据”</strong><br>  这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别。</p>
<p> 理解：公司发工资了，领导把5000元打到A的账号上，但是该事务并未提交，而A正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给A的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后A实际的工资只有2000元。</p>
<h5 id="2-读已提交rc：read-committed"><a href="#2-读已提交rc：read-committed" class="headerlink" title="- (2)读已提交rc：read committed"></a>- (2)<strong>读已提交</strong>rc：read committed</h5><p>在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。</p>
<p>  这种级别可以避免“脏数据”这种隔离级别会导致<strong>“不可重复读</strong>取</p>
<p><strong>实现原理</strong>	<br><u>读不加锁,做“快照读”并总是读最新的快照</u><br><u>写加排它锁(X锁)</u></p>
<h5 id="3-可重复读rr：repeatable-read"><a href="#3-可重复读rr：repeatable-read" class="headerlink" title="- (3)可重复读rr：repeatable read"></a>- (3)<strong>可重复读</strong>rr：repeatable read</h5><p>保证同一事务在执行同条SELECT语句数次， <strong>结果总是相同的</strong>。 </p>
<p><strong>实现原理</strong><br><u>读不加锁,做“快照读”</u><br><u>并总是读事务开始第一次读的那个版本的快照（Undo日志中）</u><br><u>写加排它锁(X锁)</u></p>
<p> 可能会导致<strong>幻读</strong>。</p>
<p> A的老婆工作在银行部门，她时常通过银行内部系统查看A的信用卡消费记录。有一天，她正在查询到A当月信用卡的总消费金额(select sum(amount)from transaction where month&#x3D;本月）为80元，而A此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录(insert transaction…),并提交了事务，随后A的老婆将A当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，A的老婆很诧异，以为出现了幻觉，幻读就这样产生了。</p>
<h5 id="实现-MVCC（多版本并发控制）-写-读"><a href="#实现-MVCC（多版本并发控制）-写-读" class="headerlink" title="!实现:MVCC（多版本并发控制）(写+读)"></a>!实现:MVCC（多版本并发控制）(写+读)</h5><p>MYSQL中<strong>可重复读和提交读</strong>隔离级别的<strong>实现方式</strong></p>
<p>MVCC的核心就是 Undo log+ Read-view，</p>
<p>•MVCC是通过undo日志来实现•<strong>读不加锁,做“快照读”</strong></p>
<p>“MV”就是通过 Undo log（回滚的基础）来保存数据的历史版本，实现多版本的管理</p>
<p>“CC”是通过 Read-view（读视图）来实现管理，通过 Read-view原则来决定数据是否显示。</p>
<p>同时针对不同的隔离级别， Read view的生成策略不同，也就实现了不同的隔离级别。</p>
<h5 id="4-串行化：serializable"><a href="#4-串行化：serializable" class="headerlink" title="- (4)串行化：serializable"></a>- (4)<strong>串行化</strong>：serializable</h5><p>用户之间通过一个接一个顺序执行当前的事务，提供了事务之间最大限度的隔离。</p>
<p>t1 -&gt; t2和t2 -&gt; t1</p>
<p>实现原理:<br><u>读加共享锁（S锁)</u><br><u>写加排它锁(X锁)</u>  </p>
<p>事务A和事务B,事务A在操作数据库时，事务B只能排队等待，直到事务A提交(反之事务B一样）<br> 这种隔离级别很少使用，吞吐量太低，用户体验差<br> 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发</p>
<h5 id="持续性"><a href="#持续性" class="headerlink" title="持续性"></a>持续性</h5><p>改变是永久的</p>
<h3 id="INNODB级别日志"><a href="#INNODB级别日志" class="headerlink" title="INNODB级别日志"></a>INNODB级别日志</h3><p>储存引擎的日志</p>
<p>Undo_log</p>
<p>Redo_log</p>
<p>实现特性的方式</p>
<h1 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h1><h4 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h4><p>数据库的锁有 排他锁，共享锁，意向锁，自增锁，间隙锁，锁的范围有包括，行锁，表锁 ，区间锁。数据库的锁有 排他锁，共享锁，意向锁，自增锁，间隙锁，锁的范围有包括，行锁，表锁 ，区间锁。</p>
<h5 id="排他锁-x2F-写锁：X"><a href="#排他锁-x2F-写锁：X" class="headerlink" title="排他锁&#x2F;写锁：X"></a>排他锁&#x2F;写锁：X</h5><p>X 锁，事务T加了排他锁，自己<strong>可读也可写</strong>。禁止并发操作。</p>
<p>Xlock</p>
<h5 id="共享锁-x2F-读锁：S"><a href="#共享锁-x2F-读锁：S" class="headerlink" title="共享锁&#x2F;读锁：S"></a>共享锁&#x2F;读锁：S</h5><p>S 锁，相对于悲观锁来说，是低一级的锁，若有事务对于某一条数据加了共享锁后，其他事务依旧可以增加共享锁，但是不能增加排他锁。</p>
<p>允许其他用户可查询 不可修改</p>
<p>slock</p>
<h4 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h4><p>R(x):读数据x</p>
<p>W(x):写数据x</p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p><u>封锁协议级别越高，一致性程度越高</u></p>
<h4 id="一级封锁协议-写前加写锁"><a href="#一级封锁协议-写前加写锁" class="headerlink" title="一级封锁协议-写前加写锁"></a>一级封锁协议-写前加写锁</h4><p>事务在<strong>修改</strong>之前需要加<strong>X</strong>锁，事务结束解锁。(其他事务不能加锁，但是可以直接读)</p>
<p>解决<u>丢失更新</u>。</p>
<p><strong>可以防止丢失修改，并且保证事务可恢复</strong></p>
<h4 id="二级封锁协议-读前加读锁，读完释放"><a href="#二级封锁协议-读前加读锁，读完释放" class="headerlink" title="二级封锁协议-读前加读锁，读完释放"></a>二级封锁协议-读前加读锁，读完释放</h4><p>base one level，事务在<strong>读</strong>之前加<strong>S</strong>锁，<strong>读完</strong>释放。</p>
<p>解决<u>污读</u></p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>事务T1封锁了数据R,事务T2又请求封锁R,于是T2等待；T3也请求封锁R,当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待；T4又请求封锁R,当T3释放了R上的封锁之后系统又批准了T4的请求2有可能永远等待，产生活锁.</p>
<p>采用<strong>先来先服务策略</strong>即可解决。</p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>事务T1封锁了数据R1,T2封锁了数据R2,T1又请求封锁R2,因T2已封锁了R2,于是T1等待T2释放R2上的锁，接着T2又申请封锁R1,因T1已封锁了R1,T2也只能等待T1,释放R1上的锁，这样T1在等待T2,而T2又在等待T1,T1和T2两个事务永远不能结束，形成死锁.</p>
<p>(1)死锁的预防<br>1.一次封锁法：每个事务必须一次将<strong>所有要使用的数据全部加锁</strong>，否则就不能继续执行<br>2.顺序封锁法：预先对数据对象规定一个封锁顺序，<u>所有事务按这个顺序实施封锁</u></p>
<p>(2)死锁的诊断与解除<br>诊断：</p>
<ol>
<li><strong>超时法</strong>：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li>
<li><strong>等待图法</strong>：构建事务等待图(有向图：节点表示运行的事务，边表示事务等待的情况)，存在回路即死锁解除：<u>选择一个处理死锁代价最小的事务，将其撤销(UNDO),</u>释放此事务持有的所有的锁</li>
</ol>
<h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>对任何数据进行读写前，需要获得该数据的封锁；当事务在释放任何一个封锁之后，不得再获得其他封锁。</p>
<p>遵循两段锁，是可串行化的充分条件，也是可能发生死锁的。</p>
<h4 id="三级封锁协议-读前加读锁，事务结束释放"><a href="#三级封锁协议-读前加读锁，事务结束释放" class="headerlink" title="三级封锁协议-读前加读锁，事务结束释放"></a>三级封锁协议-读前加读锁，事务结束释放</h4><p>base one level，事务在<strong>读</strong>之前加<strong>S</strong>锁，<strong>事务结束</strong>释放。</p>
<p>（事务T在读取数据之前必须先对其加共享锁，排它锁)</p>
<p>解决<u>重复读</u></p>
<h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>封锁的粒度越大，并发度就越小，系统开销也越小。<br>封锁的粒度越小，并发度较高，但系统开销也就越大</p>
<h4 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h4><p>在一个系统中同时支持多种封锁粒度供不同的事务选择</p>
<h4 id="多粒度树"><a href="#多粒度树" class="headerlink" title="多粒度树"></a>多粒度树</h4><p>以<strong>树形结构</strong>来表示多级封锁粒度，<strong>根结点是整个数据库</strong>，表示<strong>最大的数据粒度</strong>，<strong>叶结点</strong>表示<strong>最小的数据粒度</strong>。</p>
<p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>分为：</p>
<p>意向共享锁(Intent Share Lock，简称IS锁)<br>意向排它锁(IntentExclusive Lock，简称IX锁)<br>共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)SIX&#x3D;S+IX</p>
<p><u>Q：具有意向锁的多粒度封锁方法减少了加锁和解所的开销：</u></p>
<p>在加锁时只要从根结点检查到要<strong>加锁的结点</strong>，而<strong>不需要考虑后代结点</strong>，而后代结点的个数远远大于祖先结点，因而减少了加锁时检查的开销。</p>
<p>同时由于后代结点<strong>不需要显示加锁</strong>，从而也减少了解锁的开销。</p>
<h3 id="相容性矩阵"><a href="#相容性矩阵" class="headerlink" title="相容性矩阵"></a>相容性矩阵</h3><table>
<thead>
<tr>
<th>X</th>
<th>请求的模式</th>
<th>IS</th>
<th>S</th>
<th>IX</th>
<th>SIX</th>
</tr>
</thead>
<tbody><tr>
<td>否</td>
<td>意向共享 (IS)</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>否</td>
<td>共享 (S)</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>否</td>
<td>意向排他 (IX)</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>否</td>
<td>意向排他共享 (SIX)</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>否</td>
<td>排他 (X)</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>加入事务T1对数据对象A加了S锁，也就意味着它对A的所有下级结点加了隐式S锁，现在事务T2想要申请数据对象上的<strong>IS</strong>锁，由于IS锁表示T2将要对A的下级结点加<strong>S</strong>锁，根据S锁的定义S锁和S锁式相容的，所以T2的封锁请求可以满足，也就是说S锁和IS锁是相容的。</p>
<p>首先要明确下面的结论</p>
<ul>
<li>1.这个矩阵表示 两个事务T1 T2是否可以 同时 对同一个对象加指定的锁。</li>
<li>2.对于SIX&#x3D;S+IX锁的理解，虽然两个不同事务是不允许同时向同一对象加S，IX锁的。但是在一个事务中是可以即加S锁又加IX锁的的。因为锁就是保护事务并发的正确性，读和写两种命令在一个事务里就不存在并发的几种错误情况。但看一个事务就不需要考虑并发。理论上可以在一个事务里对同一对象又加S锁又加X锁，但根本没这个必要。</li>
</ul>
<hr>
<ul>
<li>T1加S锁，表示数据的子节点都是隐式的加了 S 锁<ul>
<li>T2 加 S 相容 都是读锁</li>
<li>T2 加 IS 相容 都是读锁</li>
<li>T2 加 IX ，不相容， IX 对子节点 意向 加 X 锁（逻辑上可能不会对子节点加 X ，但是只要这个可能性存在就要保证正确性） ，和 S 锁冲突</li>
<li>T2 加 SIX, 不相容， 同 上面加 IX</li>
<li>T2 加 X ， 不相容， S 和 X 冲突</li>
</ul>
</li>
<li>T1加X锁，<ul>
<li>T2只能干等着。因为X锁排他，优先级最高</li>
</ul>
</li>
<li>T1加IS锁<ul>
<li>T2不能加X锁。因为T1有对其子节点加S锁的可能而T2扼杀了这个可能性。</li>
<li>T2 加 IX锁 相容 是因为I锁只是意向锁，所以是可行的，若事务有非意向锁，根据相容矩阵再次判定。SIX锁综上同理。</li>
</ul>
</li>
<li>T1加IX锁，<ul>
<li>T2不能加S，X，SIX锁的原因不再赘述。(不能加SIX锁的原因，可参考不能加S锁)</li>
</ul>
</li>
<li>T1加SIX锁，<ul>
<li>T2只能加IS锁。不能加S，X，IX，SIX锁的原因分别是：</li>
<li>T2 加 S 不相容，T1无法完成SIX锁的IX部分</li>
<li>T2 加 X 不相容，T1首先就无法完成S锁，更别说SIX锁</li>
<li>T2 加 IX 不相容，表示T2意向修改对象子节点，而T1要读对象，若T2修改其子节点便产生并发错误。故pass</li>
<li>T2 加 SIX 不相容，综合上面S和IX的情况。pass</li>
</ul>
</li>
</ul>
<h1 id="恢复技术"><a href="#恢复技术" class="headerlink" title="恢复技术"></a>恢复技术</h1><h4 id="常见损坏"><a href="#常见损坏" class="headerlink" title="常见损坏"></a>常见损坏</h4><h5 id="事务内部故障"><a href="#事务内部故障" class="headerlink" title="事务内部故障"></a>事务内部故障</h5><p>事务没有到达终点.</p>
<ul>
<li>可预期</li>
<li>不可预期<ul>
<li>运算溢出</li>
<li>发生死锁, 被选中撤销</li>
<li>违反完整性约束</li>
</ul>
</li>
</ul>
<h5 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h5><ul>
<li>cpu</li>
<li>操作系统</li>
<li>代码错误</li>
<li>断电</li>
</ul>
<h5 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h5><p>硬故障,外存故障</p>
<p>发生可能性小,破坏性大.</p>
<ul>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>瞬时强磁场干扰.</li>
</ul>
<h5 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h5><p>人为破坏</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理:"></a>基本原理:</h4><p><strong>数据冗余</strong></p>
<h4 id="恢复实现"><a href="#恢复实现" class="headerlink" title="恢复实现"></a>恢复实现</h4><p>如何建立冗余数据:</p>
<h5 id="1-数据转储-备份backup"><a href="#1-数据转储-备份backup" class="headerlink" title="1. 数据转储(备份backup);"></a>1. <strong>数据转储</strong>(备份backup);</h5><p>   定期将数据复制到磁带磁盘和其他存储介质.(提前写转储计划) </p>
<p>   后备副本</p>
<p>   转储方法:</p>
<h6 id="1-静态转储和动态转储"><a href="#1-静态转储和动态转储" class="headerlink" title="(1)静态转储和动态转储"></a>(1)静态转储和动态转储</h6><p>   静态:系统中无运行事务时进行,得到的一定是一个数据一致性的副本.</p>
<p>   转储必须等正在运行的用户事务结束.</p>
<p>   动态:</p>
<h6 id="2-海量转储和增量转储"><a href="#2-海量转储和增量转储" class="headerlink" title="(2)海量转储和增量转储"></a>(2)海量转储和增量转储</h6><p>   海量:全部备份</p>
<p>   增量:只转储上次转储后更新过的数据</p>
<p>增量备份通过二进制日志来实现。</p>
<h5 id="2-登记日志文件-logging"><a href="#2-登记日志文件-logging" class="headerlink" title="2. 登记日志文件(logging)"></a>2. 登记日志文件(logging)</h5><p>   原则:</p>
<p>   Ⅰ. 先写日志文件,后写数据库</p>
<p>   原因:若颠倒,日志上没有登记下修改,以后无法恢复这个修改.</p>
<p>   Ⅱ. 登记的次序要严格按照并发事务执行的时间</p>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><h5 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h5><p><strong>UNDO</strong></p>
<h5 id="系统故障（软故障）"><a href="#系统故障（软故障）" class="headerlink" title="系统故障（软故障）"></a>系统故障（软故障）</h5><p>系统故障的情况下，在系统重新启动后，恢复子系统除了需要撤销<strong>UNDO</strong>未完成的事务以外，还需要<strong>REDO</strong>（事务重做）<br>所有已提交的事务。</p>
<h5 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h5><ol>
<li>重装数据库<br>装入最新的后备数据库副本,<strong>恢复到最近一次一致性状态</strong>.</li>
<li>重做<strong>REDO</strong></li>
</ol>
<h5 id="计算及病毒会产生上述故障"><a href="#计算及病毒会产生上述故障" class="headerlink" title="计算及病毒会产生上述故障"></a>计算及病毒会产生上述故障</h5><p>采用相应的恢复策略</p>
<h3 id="mysql备份工具"><a href="#mysql备份工具" class="headerlink" title="mysql备份工具"></a>mysql备份工具</h3><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>备份结果为可读的SQL文件，可用于跨版本跨平台恢复数据。<br>备份文件的尺寸小于物理备份，便于长时间存储。<br>mysql发行自带工具，无需安装第三方软件<br>Mysqldump热备全量逻辑备份</p>
<p>导出逻辑备份数据，备份较慢<br>还原需要执行sql语句，速度较慢<br>由于mysqldump的备份原理是对数据库发出很多条select请求,所以对数据库造成一定的负担。</p>
<h4 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h4><p>第三方percano公司研发的免费的物理备份工具<br>直接备份INNODB底层数据文件<br>导出不需要转换为SQL语句，速度快<br>工作时对数据库的压力较小</p>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>一、数据库设计的生存期</p>
<p>① <strong>需求分析</strong></p>
<p>需求收集和分析，得到用数据字典描述的数据需求，用数据流图描述的处理需求。明确数据的生命周期， 存储<br>特点。</p>
<p>分析用户以及应用系统的数据需求<br>明确在数据库中需要存储和管理的数据<br>明确用户对数据的安全性和完整性方面的需求<br>明确数据的生命周期，存储特点（案例参考）</p>
<p>② <strong>概念结构设计</strong></p>
<p>对需求进行综合、归纳与抽象，形成一个<strong>独立于具体DBMS的概念模型</strong>（用E-R表示）。借助E-R模型，表达数据抽象结果，得到独立于具体的DBMS的概念模型</p>
<p>③ <strong>逻辑结构设计</strong></p>
<p>将概念结构转换为某个DBMS所支持的数据模型（例如关系模型），并对其进行优化。关系规范化理论。</p>
<p>对于关系模型，将关系模型转换为关系数据库模式<br>遵循转换规则<br>运用关系规范化理论</p>
<p>④ <strong>物理结构设计</strong></p>
<p>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。</p>
<p>程序设计：应用程序设计的工作开始于物理设计</p>
<p>采用数据定义语言定义数据库模式<br>确定适合应用环境的存储结构和存取方法</p>
<p>⑤ <strong>数据库实施</strong></p>
<p>运用DBMS提供的数据语言（例如SQL）及其宿主语言（例如C），根据逻辑设计和物理设计的结果</p>
<p>建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</p>
<p>建立数据库<br>进行数据库编程<br>组织数据入库<br>测试数据库</p>
<p>⑥ <strong>数据库运行和维护</strong></p>
<p>数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改。</p>
<p>对数据库进行评估<br>完善数据库<br>重组织<br>重构造</p>
<p>说明：设计一个完善的数据库应用系统是不可能一蹴而就的，它往往是上述六个阶段的不断反复。</p>
<p>二、数据库设计阶段的内容</p>
<p>三、数据库设计阶段的模式</p>
<p>数据库结构设计的不同阶段形成数据库的各级模式，如下图。</p>
<p>需求分析阶段：综合各个用户的应用需求；</p>
<p>概念设计阶段：形成独立于机器特点，独立于各个DBMS产品的概念模式，即E-R图；</p>
<p>逻辑设计阶段：将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式；然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的外模式；</p>
<p>物理设计阶段：根据DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。</p>
<h1 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h1><p>第四章：数据库安全性（授权）<br>1、不安全因素<br>①非授权用户对数据库的恶意存取和破坏<br>②数据库中重要数据的泄露<br>③安全环境的脆弱性<br>2、数据库安全性控制<br>①用户身份鉴别：静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别<br>②存取控制<br>③自主存取控制方法<br><strong>3、为什么要授权</strong><br>授权是指授予(GRANT)和收回(REVOKE),是数据库安全性控制中的自主存取控制方法。是为了保护数据库<br>防止不合法使用所造成的数据泄露、更改或破坏。<br>4、如何授权：授予GRANT<br>发出如下语句的可以是数据库管理员、也可以是数据库对象创建者、也可以是已经拥有该权限的用户<br>GRANT权限ON对象类型对象名TO用户名WITH GRANT OPTION];<br>权限：查询权限SELECT,全部操作权限ALL PRIVILEGES<br>对象类型&amp;对象名：对象类型可以是TABLE也可以是VEW,对象名为对应的表名或者视图名<br>用户名：可以是指定用户，也可以是全体用户PUBLIC<br>如果没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限<br>注意：SQL不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先<br>eg.把查询权限授给用户U1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON TABLE Student TO U1;</span><br></pre></td></tr></table></figure>

<p>5、收回授权：收回REVOKE<br>REVOKE权限ON对象类型对象名FROM用户名[CASCADERESTRICT,<br>CASCADE:级联回收。将用户传播出去的权限一并收回<br>RESTRICT:受限回收。若用户传播过该权限，回收将会失败<br>eg.把用户U4修改学生学号的权限收回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span>(Sno)<span class="keyword">ON</span> <span class="keyword">TABLE</span> Student <span class="keyword">FROM</span> U4;</span><br></pre></td></tr></table></figure>

<p>6、创建数据库模式的权限<br>对抢创建数据库模式一类的数据库对象的授权再数据库管理员创建用户时实现：<br>CREATE USER username [WITH DBARESOURCECONNECT];<br>只有系统的超级用户才有权创建一个新的数据库用户，新创建的数据库用户有三种权限：DBA、RESOURCE、<br>CONNECT（此为默认）<br>DBA：可以创建新用户、创建模式、创建基本表和视图等，拥有对所有数据库对象的存取权限，还可以把这些权限<br>授予一般用户<br>RESOURCE:可以创建基本表和视图，但不能创建模式和新用户。数据库对象的属主可以用GRANT语句把该对象<br>上的存取权限授予其他用户<br>CONNECT：只能登陆数据库，根据其他用户或者数据库管理员授予的权限的情况对数据库对象进行权限范围内的<br>操作<br>7、数据库角色<br>角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过<br>程<br>创建角色：CREATE ROLE角色名；<br>在一个角色中添加角色或者用户：GRANT角色TO某角色&#x2F;某用户WITH ADMIN OPTION]:<br>指定NITH ADMIN OPTION子句，则获得某种权限的角色或者用户还可以把这种权限再授予其他角色</p>
<p>5、收回授权：收回REVOKE<br>REVOKE权限ON对象类型对象名FROM用户名[CASCADERESTRICT,<br>CASCADE:级联回收。将用户传播出去的权限一并收回<br>RESTRICT:受限回收。若用户传播过该权限，回收将会失败<br>eg.把用户U4修改学生学号的权限收回<br>REVOKE UPDATE(Sno)ON TABLE Student FROM U4;<br>6、创建数据库模式的权限<br>对抢创建数据库模式一类的数据库对象的授权再数据库管理员创建用户时实现：<br>CREATE USER username [WITH DBARESOURCECONNECT];<br>只有系统的超级用户才有权创建一个新的数据库用户，新创建的数据库用户有三种权限：DBA、RESOURCE、<br>CONNECT（此为默认）<br>DBA：可以创建新用户、创建模式、创建基本表和视图等，拥有对所有数据库对象的存取权限，还可以把这些权限<br>授予一般用户<br>RESOURCE:可以创建基本表和视图，但不能创建模式和新用户。数据库对象的属主可以用GRANT语句把该对象<br>上的存取权限授予其他用户<br>CONNECT：只能登陆数据库，根据其他用户或者数据库管理员授予的权限的情况对数据库对象进行权限范围内的<br>操作<br>7、数据库角色<br>角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过<br>程<br>创建角色：CREATE ROLE角色名；<br>在一个角色中添加角色或者用户：GRANT角色TO某角色&#x2F;某用户WITH ADMIN OPTION]:<br>指定NITH ADMIN OPTION子句，则获得某种权限的角色或者用户还可以把这种权限再授予其他角色</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>记录发生的错误。</p>
<h2 id="慢查日志"><a href="#慢查日志" class="headerlink" title="慢查日志"></a>慢查日志</h2><p>记录执行时间超过指定时间的操作。</p>
<h2 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h2><p>所有向mysql发出的请求。</p>
<h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>记录全部有效的数据修改日志。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常用软件的安装教程</title>
    <url>/2023/02/25/test/%E5%A6%82%E4%BD%95%E7%99%BD%E5%AB%96office%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p>支持正版！</p>
<span id="more"></span>

<h1 id="1-office系列"><a href="#1-office系列" class="headerlink" title="1. office系列"></a>1. office系列</h1><ol>
<li>参考视频：<a href="https://www.bilibili.com/video/BV1g64y1d7az?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1g64y1d7az?spm_id_from=333.999.0.0</a></li>
<li>下载office tool plus</li>
<li>部署完毕</li>
<li>输入命令&#x2F;osppilbyid ProPlus2021Volume &#x2F;osppsethst:kms.loli.beer &#x2F;osppsetprt:1688 &#x2F;osppact</li>
</ol>
<p>kms.cangshui.net（这个命令经常会变，请上网找到最新的命令）</p>
]]></content>
  </entry>
  <entry>
    <title>动手学深度学习v2补充解释</title>
    <url>/2023/11/13/test/%E6%9D%8E%E6%B2%90/</url>
    <content><![CDATA[<h1 id="动手学深度学习v2"><a href="#动手学深度学习v2" class="headerlink" title="动手学深度学习v2"></a>动手学深度学习v2</h1><p>个人不理解的地方，进行一些原理的证明或是详细解释。</p>
<span id="more"></span>

<h2 id="每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致"><a href="#每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致" class="headerlink" title="每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致"></a>每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致</h2><p>来源：14 模型初始化和激活函数</p>
<p>如果每层的输出和梯度都具有相同的均值和方差，那么在反向传播过程中，梯度会保持相同的比例。这样，梯度值在各层之间就不会发生太大的变化，从而减轻梯度消失或爆炸的问题。</p>
<p>假设每层的输出和梯度都具有相同的均值和方差，即： $$E[h^t] &#x3D; E[g^t] &#x3D; 0$$ $$Var[h^t] &#x3D; Var[g^t] &#x3D; \sigma^2$$ 在反向传播过程中，梯度是通过链式法则计算的： $$g^{t-1} &#x3D; \frac{d}{dh^{t-1}} L(h^t, y)$$ 其中，$L$ 是损失函数。 根据链式法则，我们有： $$g^{t-1} &#x3D; \sigma’(W^th^{t-1}) W^t$$ 其中，$\sigma$ 是激活函数。 由于 $h^{t-1}$ 和 $g^t$ 都具有相同的均值和方差，因此 $\sigma’(W^th^{t-1})$ 也具有相同的均值和方差。 因此，我们有： $$E[g^{t-1}] &#x3D; \sigma’(0) E[W^t] &#x3D; 0$$ $$Var[g^{t-1}] &#x3D; \sigma’^2(0) Var[W^t] &#x3D; \sigma^2$$ 因此，在反向传播过程中，梯度的均值保持为零，而梯度的方差保持为 $\sigma^2$。 也就是说，在反向传播过程中，梯度会保持相同的比例。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>K-means讲解</title>
    <url>/2023/11/15/test/k-means/</url>
    <content><![CDATA[<p>K-means的一些讲解</p>
<span id="more"></span>   

<meta name="referrer" content="no-referrer" />


<h1 id="k-均值算法"><a href="#k-均值算法" class="headerlink" title="k 均值算法"></a>k 均值算法</h1><p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/1234333422.gif"></p>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20201018202041.png"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h2><ul>
<li>随机选取样本作为初始均值向量（初始值：k 的值【即几个簇】）（也可以不用样本点）</li>
<li>分别计算每个样本点到初始均值向量的<strong>距离</strong>（数据做了标准化），距离哪个点最近就属于哪个簇</li>
<li>每个簇重新计算中心点，重复第二步直到<strong>收敛</strong></li>
<li>找到质心和离某个质心距离最近的点就分为一类。</li>
</ul>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20210210021340.png"></p>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20210210021518.png"></p>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20210210021531.png"></p>
<blockquote>
<p>问题：需要指定k值，难以确定k值。</p>
</blockquote>
<h2 id="确定k值"><a href="#确定k值" class="headerlink" title="确定k值"></a>确定k值</h2><h3 id="1-手肘法"><a href="#1-手肘法" class="headerlink" title="1.手肘法"></a>1.手肘法</h3><p>手肘法的核心指标是SSE(sum of the squared errors，误差平方和)，</p>
<p>$$S S E &#x3D; \sum _ { i &#x3D; 1 } ^ { k } \sum _ {  p∈m_i }| p - m _ {i } | ^ { 2 }$$</p>
<p>其中，Ci是第i个簇，p是Ci中的样本点，mi是Ci的质心（Ci中所有样本的均值），SSE是所有样本的聚类误差，代表了聚类效果的好坏。</p>
<p>手肘法的核心思想是：随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。并且，当k小于真实聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达真实聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的真实聚类数。当然，这也是该方法被称为手肘法的原因。</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/image-20231115213147472.png"></p>
<h3 id="2-轮廓系数法"><a href="#2-轮廓系数法" class="headerlink" title="2. 轮廓系数法"></a>2. 轮廓系数法</h3><p>该方法的核心指标是轮廓系数（Silhouette Coefficient），某个样本点Xi的轮廓系数定义如下：</p>
<p>$$S &#x3D; \frac { b - a } { m a x ( a , b ) }$$</p>
<p>其中，a是Xi与同簇的其他样本的平均距离，称为凝聚度，b是Xi与最近簇中所有样本的平均距离，称为分离度。而最近簇的定义是</p>
<p>$$C _ { j } &#x3D;{ a r g } m i n \frac { 1 } { n } \sum _ { p ∈c _ { s } } | p - X _ { i }| ^ { 2 }$$</p>
<p>其中p是某个簇Ck中的样本。事实上，简单点讲，就是用Xi到某个簇所有样本平均距离作为衡量该点到该簇的距离后，选择离Xi最近的一个簇作为最近簇。</p>
<p>求出所有样本的轮廓系数后再求平均值就得到了<strong>平均轮廓系数</strong>。平均轮廓系数的取值范围为[-1,1]，且簇内样本的距离越近，簇间样本距离越远，平均轮廓系数越大，聚类效果越好。那么，很自然地，平均轮廓系数最大的k便是最佳聚类数。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>聚类算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
