<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>公司任务</title>
    <url>/2023/02/25/test/Pandas%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<p>公司任务：有五个设备统计53周电器用电数据。现在要拆分到每周每种电器用电数据。 <span id="more"></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 五个设备的表格，按周分别拆分出53个表格，共计53*3=159个表格</span></span><br><span class="line">data1 = pd.read_excel(<span class="string">&quot;CRT2_OUTPUT (1).xlsx&quot;</span>)</span><br><span class="line">gb = data1.groupby(<span class="string">&#x27;FISCAL_WEEK&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> week,df_son <span class="keyword">in</span> gb:</span><br><span class="line">	df_son.to_excel(<span class="string">f&#x27;<span class="subst">&#123;week&#125;</span>.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 再给五个设备合并</span></span><br><span class="line">path = <span class="string">&#x27;./APS2&#x27;</span> </span><br><span class="line">dlj = os.listdir(path)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dlj:</span><br><span class="line">    name1=<span class="string">&#x27;./APS2/&#x27;</span>+i</span><br><span class="line">    data1 = pd.read_excel(name1)</span><br><span class="line">    name2=<span class="string">&#x27;./CART2/&#x27;</span>+i</span><br><span class="line">    data2 = pd.read_excel(name2)</span><br><span class="line">    name3=<span class="string">&#x27;./FIN2/&#x27;</span>+i</span><br><span class="line">    data3 = pd.read_excel(name3)</span><br><span class="line">    name4=<span class="string">&#x27;./ODT2/&#x27;</span>+i</span><br><span class="line">    data4 = pd.read_excel(name4)</span><br><span class="line">    name5=<span class="string">&#x27;./PRE2/&#x27;</span>+i</span><br><span class="line">    data5 = pd.read_excel(name5)</span><br><span class="line">    datanew = pd.concat([data1,data2,data3,data4,data5], axis=<span class="number">0</span>)</span><br><span class="line">    datanew.to_excel(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 再分别计算五个设备的和    </span></span><br><span class="line">path = <span class="string">&#x27;./MERGE&#x27;</span> </span><br><span class="line">dlj = os.listdir(path)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dlj:</span><br><span class="line">    name1=<span class="string">&#x27;./MERGE/&#x27;</span>+i</span><br><span class="line">    data1 = pd.read_excel(name1)</span><br><span class="line">    datanew = data1.groupby([<span class="string">&#x27;PART_NUM&#x27;</span>])[<span class="string">&#x27;OUTPUT&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">    datanew.to_excel(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 再将53周合并到一个表格里，这里因为每周电器设备不同，用concat不太好，改用merge。</span></span><br><span class="line">path = <span class="string">&#x27;G:/桌面/e/type2/MERGE_SUM/&#x27;</span> </span><br><span class="line">dlj = os.listdir(path)</span><br><span class="line">datanew = pd.read_excel(<span class="string">&#x27;2.xlsx&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dlj:</span><br><span class="line">    name1 = path+i</span><br><span class="line">    data1 = pd.read_excel(name1)</span><br><span class="line">    datanew = pd.merge(datanew, data1, how=<span class="string">&#x27;outer&#x27;</span>, on=[<span class="string">&#x27;PART_NUM&#x27;</span>])</span><br><span class="line">datanew.to_excel(<span class="string">&#x27;a.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>Pandas</category>
      </categories>
  </entry>
  <entry>
    <title>R语言-时间序列分析</title>
    <url>/2023/03/24/test/R%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文介绍时间序列模型的基本r语言代码，包括平稳性和非平稳性的处理。</p>
<span id="more"></span>

<h1 id="一个完整的Arma模型分析处理"><a href="#一个完整的Arma模型分析处理" class="headerlink" title="一个完整的Arma模型分析处理"></a>一个完整的Arma模型分析处理</h1><h2 id="arma模型平稳性判别"><a href="#arma模型平稳性判别" class="headerlink" title="arma模型平稳性判别"></a>arma模型平稳性判别</h2><h2 id="1-时序图绘制"><a href="#1-时序图绘制" class="headerlink" title="1. 时序图绘制"></a>1. 时序图绘制</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 时间序列的赋值</span></span><br><span class="line">rain<span class="operator">&lt;-</span>ts<span class="punctuation">(</span>data<span class="operator">$</span>price<span class="punctuation">,</span>start<span class="operator">=</span><span class="number">2015</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 时间序列的子序列</span></span><br><span class="line">rain2<span class="operator">&lt;-</span>window<span class="punctuation">(</span>rain<span class="punctuation">,</span>start<span class="operator">=</span><span class="number">2016</span><span class="punctuation">,</span>end<span class="operator">=</span><span class="number">2018</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># data表格的price列，开始是2015年</span></span><br><span class="line"><span class="comment"># 2. 绘制</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>



<h2 id="3-噪声检验（纯随机检验）"><a href="#3-噪声检验（纯随机检验）" class="headerlink" title="3. 噪声检验（纯随机检验）"></a>3. 噪声检验（纯随机检验）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>k <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span> print<span class="punctuation">(</span>Box.test<span class="punctuation">(</span>white_noise<span class="punctuation">,</span>lag<span class="operator">=</span><span class="number">6</span><span class="operator">*</span>k<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&quot;Ljung-Box&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="comment">#噪声检验</span></span><br><span class="line"><span class="comment"># type=&#x27;Box-Pierce&#x27;是Q检验量</span></span><br><span class="line"><span class="comment">## 输出LB统计量和P值</span></span><br><span class="line"><span class="comment">## p值大于0.05则不能拒绝</span></span><br></pre></td></tr></table></figure>

<p>结果分析：显示延迟6和12阶的LB统计量的P值<strong>小于</strong>显著性水平（α &#x3D; 0.05)，所以可以判断该序列为平稳非白噪声序列。</p>
<h3 id="DF-x2F-ADF平稳性检验"><a href="#DF-x2F-ADF平稳性检验" class="headerlink" title="DF&#x2F;ADF平稳性检验"></a>DF&#x2F;ADF平稳性检验</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;aTSA&#x27;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>aTSA<span class="punctuation">)</span></span><br><span class="line">adf.test<span class="punctuation">(</span>overshort<span class="punctuation">,</span>nlag<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># P值为0.01小于0.05，所以该序列平稳</span></span><br></pre></td></tr></table></figure>
<p>DF检验针对AR(1)，是ADF的特例。<br>结果分析：6中子类型，τ统计量的<strong>P值均显著大于显著性水平</strong>（α &#x3D; 0.05)，因此可以判断，如果序列考虑如上6种结构之一提取确定性信息，则随机性部分都不能实现平稳。<br>所以序列是<strong>非平稳序列</strong>。<br>若存在小于显著性水平的，则是平稳序列。</p>
<h2 id="2-自相关图and偏自相关图（模型定阶）"><a href="#2-自相关图and偏自相关图（模型定阶）" class="headerlink" title="2. 自相关图and偏自相关图（模型定阶）"></a>2. 自相关图and偏自相关图（模型定阶）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lag延迟阶数</span></span><br><span class="line"><span class="comment"># plot=True，只输出自相关图，不输出系数；False，反之。</span></span><br><span class="line">acf<span class="punctuation">(</span>x<span class="punctuation">,</span>lag.max<span class="operator">=</span><span class="punctuation">,</span>plot<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line">pacf<span class="punctuation">(</span>x<span class="punctuation">,</span>lag.max<span class="operator">=</span><span class="punctuation">,</span>plot<span class="operator">=</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>结果分析：<br>判断是截尾还是拖尾，然后分析模型属于哪一种。</p>
<p>自相关图是自相关系数，虚线是自相关系数两倍标准差的参考线。落在两倍标差外，则认为自相关系数很大，显著非零。</p>
<h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x.fit<span class="operator">&lt;-</span>arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># order为模型阶数:自回归阶数、差分阶数、移动平均阶数。</span></span><br><span class="line"><span class="comment"># include.mean要不要包含均值</span></span><br><span class="line"><span class="comment"># method=&quot;CSS-ML&quot;最小二乘和极大似然的混合 也可以单独使用一种</span></span><br></pre></td></tr></table></figure>
<h3 id="模型检验：残差分析"><a href="#模型检验：残差分析" class="headerlink" title="模型检验：残差分析"></a>模型检验：残差分析</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>aTSA<span class="punctuation">)</span></span><br><span class="line">ts.diag<span class="punctuation">(</span>x.fit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果输出四图</p>
<p>ACF&#x2F;PACF图：需要所有竖线全都在<strong>蓝色虚线内</strong>(95%CI)。</p>
<p>第三幅图：残差序列的白噪声检验，观察各阶延迟下的白噪声检验统计量的<strong>P值是否都显著的大于0.05</strong>。若都显著，则残差序列属于白噪音序列，拟合模型显著成立。<br>第四幅图：QQ图，正态分布假定的检验。如果点<strong>密集地分布在对角线左右</strong>，则该序列近似服从正态分布。</p>
<h3 id="参数的显著性检验"><a href="#参数的显著性检验" class="headerlink" title="参数的显著性检验"></a>参数的显著性检验</h3><p>检验每一个未知参数是否显著非零<br>目的：精简模型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 近似方法</span></span><br><span class="line">x.fit</span><br><span class="line"><span class="comment"># 2. 精确方法</span></span><br><span class="line"><span class="comment"># 构造t统计量，调用pt函数求p值</span></span><br><span class="line">t <span class="operator">=</span> <span class="built_in">abs</span><span class="punctuation">(</span>fit<span class="operator">$</span>coef<span class="punctuation">)</span><span class="operator">/</span><span class="built_in">sqrt</span><span class="punctuation">(</span>diag<span class="punctuation">(</span>fit2<span class="operator">$</span>var.coef<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">pt<span class="punctuation">(</span>t<span class="punctuation">,</span><span class="built_in">length</span><span class="punctuation">(</span>overshort<span class="punctuation">)</span><span class="operator">-</span><span class="built_in">length</span><span class="punctuation">(</span>fit1<span class="operator">$</span>coef<span class="punctuation">)</span><span class="punctuation">,</span>lower.tail<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># t统计量的值，自由度，参数估计值为正</span></span><br></pre></td></tr></table></figure>
<h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BIC<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">AIC<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="识别最优阶数"><a href="#识别最优阶数" class="headerlink" title="识别最优阶数"></a>识别最优阶数</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.package<span class="punctuation">(</span><span class="string">&#x27;forecast&#x27;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>forecast<span class="punctuation">)</span></span><br><span class="line">auto.arima<span class="punctuation">(</span>x<span class="punctuation">,</span>ic<span class="operator">=</span><span class="string">&#x27;bic&#x27;</span><span class="punctuation">)</span></span><br><span class="line">auto.arima<span class="punctuation">(</span>x<span class="punctuation">,</span>ic<span class="operator">=</span><span class="string">&#x27;aic&#x27;</span><span class="punctuation">)</span><span class="comment"># 默认</span></span><br></pre></td></tr></table></figure>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>forecast<span class="punctuation">)</span></span><br><span class="line">fore<span class="operator">&lt;-</span>forecast<span class="operator">::</span>forecast<span class="punctuation">(</span>fit<span class="punctuation">,</span>h<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span><span class="comment">#预测未来十个数据</span></span><br><span class="line">plot<span class="punctuation">(</span>x.fore<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="非平稳处理"><a href="#非平稳处理" class="headerlink" title="非平稳处理"></a>非平稳处理</h1><h2 id="线性拟合"><a href="#线性拟合" class="headerlink" title="线性拟合"></a>线性拟合</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 40年</span></span><br><span class="line">t <span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">40</span><span class="punctuation">)</span></span><br><span class="line">x.fit <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>x<span class="operator">~</span>t<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 查看拟合信息</span></span><br><span class="line">summary<span class="punctuation">(</span>x.fit<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 画拟合图</span></span><br><span class="line">x <span class="operator">&lt;-</span> ts<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">abline<span class="punctuation">(</span>lm<span class="punctuation">(</span>x<span class="operator">~</span>t<span class="punctuation">)</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><h3 id="可用线性最小二乘"><a href="#可用线性最小二乘" class="headerlink" title="可用线性最小二乘"></a>可用线性最小二乘</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t1<span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">60</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 转化</span></span><br><span class="line">t2<span class="operator">&lt;-</span>t1<span class="operator">^</span><span class="number">2</span></span><br><span class="line">x.fit1<span class="operator">&lt;-</span>;m<span class="punctuation">(</span>x<span class="operator">~</span>t1<span class="operator">+</span>t2<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>x.fit1<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="不可用线性最小二乘"><a href="#不可用线性最小二乘" class="headerlink" title="不可用线性最小二乘"></a>不可用线性最小二乘</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x.fit2<span class="operator">&lt;-</span>nls<span class="punctuation">(</span>x<span class="operator">~</span>a<span class="operator">+</span>b<span class="operator">*</span>t1<span class="operator">+</span><span class="built_in">c</span><span class="operator">*</span>t1<span class="operator">^</span><span class="number">2</span><span class="punctuation">,</span>start<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>a<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>b<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span><span class="built_in">c</span><span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>x.fit2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 画图</span></span><br><span class="line">y<span class="operator">&lt;-</span>predict<span class="punctuation">(</span>x.fit2<span class="punctuation">)</span><span class="comment">#把nls函数得到的拟合值赋值给y</span></span><br><span class="line">y<span class="operator">&lt;-</span>ts<span class="punctuation">(</span>y<span class="punctuation">,</span>start<span class="operator">=</span><span class="number">1949</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&quot;p&quot;</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>y<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="移动平均拟合"><a href="#移动平均拟合" class="headerlink" title="移动平均拟合"></a>移动平均拟合</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动平均拟合</span></span><br><span class="line">library<span class="punctuation">(</span>TTR<span class="punctuation">)</span></span><br><span class="line">x<span class="operator">&lt;-</span></span><br><span class="line"><span class="comment"># 选择期数 进行拟合</span></span><br><span class="line">x.ma<span class="operator">&lt;-</span>SMA<span class="punctuation">(</span>x<span class="punctuation">,</span>n<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>tyoe<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>x.ma<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指数平滑"><a href="#指数平滑" class="headerlink" title="指数平滑"></a>指数平滑</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x<span class="operator">&lt;-</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span>x<span class="punctuation">,</span>alpha<span class="operator">=</span><span class="punctuation">,</span> beta<span class="operator">=</span><span class="punctuation">,</span> <span class="built_in">gamma</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span>seasonal<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 简单指数平滑</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span>x<span class="punctuation">,</span>beta<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">gamma</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Holt两参数平滑</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span><span class="built_in">gamma</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Holt&#x27;三参数平滑</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>HoltWinters<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># seasonal：季节和趋势的关系</span></span><br><span class="line"><span class="comment"># seasonal=&#x27;additive&#x27;;seasonal=&#x27;multiplicative&#x27;</span></span><br><span class="line"><span class="comment"># 默认加法，seasonal=&#x27;mult&#x27;乘法</span></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line">plot<span class="punctuation">(</span>x.fit<span class="punctuation">)</span></span><br><span class="line">x.fore<span class="operator">&lt;-</span>forecast<span class="punctuation">(</span>x.fit<span class="punctuation">,</span>h<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x.fore<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="季节指数、趋势效应、随机效应分解"><a href="#季节指数、趋势效应、随机效应分解" class="headerlink" title="季节指数、趋势效应、随机效应分解"></a>季节指数、趋势效应、随机效应分解</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> ts<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 乘法模型</span></span><br><span class="line">x.fit <span class="operator">&lt;-</span> decompose<span class="punctuation">(</span>x<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;mult&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 加法模型</span></span><br><span class="line">x.fit <span class="operator">&lt;-</span> decompose<span class="punctuation">(</span>x<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;addi&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以查看季节指数、趋势效应、随机效应</span></span><br><span class="line">x.fit<span class="operator">$</span>figure</span><br><span class="line">x.fit<span class="operator">$</span>trend</span><br><span class="line">x.fit<span class="operator">$</span>random</span><br></pre></td></tr></table></figure>

<h2 id="无季节效应差分运算"><a href="#无季节效应差分运算" class="headerlink" title="无季节效应差分运算"></a>无季节效应差分运算</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">diff<span class="punctuation">(</span>x<span class="punctuation">,</span>d<span class="punctuation">,</span>k<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 进行k次d步差分</span></span><br></pre></td></tr></table></figure>

<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> ts<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画原时间序列</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 原时序图有线性趋势</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1阶差分</span></span><br><span class="line">x.dif<span class="operator">&lt;-</span>diff<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1阶差分后的时序图\自相关图和偏相关图</span></span><br><span class="line">plot<span class="punctuation">(</span>x.dif<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 时序图在均值附近稳定波动</span></span><br><span class="line"></span><br><span class="line">acf<span class="punctuation">(</span>x.dif<span class="punctuation">)</span></span><br><span class="line">pacf<span class="punctuation">(</span>x.dif<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 观察截尾拖尾性质，判断拟合模型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="punctuation">,</span>transform.par<span class="operator">=</span><span class="punctuation">,</span>fixed<span class="operator">=</span><span class="punctuation">,</span>seasonal<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># order为非季节效应部分的模型阶数</span></span><br><span class="line"><span class="comment"># 是否需要拟合常数项，参数估计方法，是否需要人为干预参数估计，疏系数模型指定疏系数的位置</span></span><br><span class="line"><span class="comment"># seasonal =  list(order=c(P,D,Q),period=s)</span></span><br><span class="line"><span class="comment"># 加法：p=0,q=o;乘法:p/q不全为0</span></span><br><span class="line"><span class="comment"># 拟合</span></span><br><span class="line">x.fit<span class="operator">&lt;-</span>arima<span class="punctuation">(</span>x<span class="punctuation">,</span>orderc<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 有季节因素的乘法模型</span></span><br><span class="line">fit2 <span class="operator">&lt;-</span>arima<span class="punctuation">(</span>x3<span class="punctuation">,</span>order <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>seasonal<span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>order <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>period <span class="operator">=</span><span class="number">12</span><span class="punctuation">)</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="string">&#x27;ML&#x27;</span><span class="punctuation">)</span><span class="comment">#经过多次试探性降阶尝试，拟合AIC值较</span></span><br><span class="line"><span class="comment"># 残差白噪声检验</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span> print<span class="punctuation">(</span>Box.test<span class="punctuation">(</span>x.fit<span class="punctuation">,</span>lag<span class="operator">=</span><span class="number">6</span><span class="operator">*</span>i<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 白噪声p值大于0.05：显著成立才算拟合成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">x<span class="punctuation">,</span>fore<span class="operator">&lt;-</span>forecast<span class="punctuation">(</span>x.fit<span class="punctuation">,</span>h<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测图</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="根据拟合结果写出拟合模型"><a href="#根据拟合结果写出拟合模型" class="headerlink" title="根据拟合结果写出拟合模型"></a>根据拟合结果写出拟合模型</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x.fit</span><br><span class="line"><span class="comment"># 观察输出</span></span><br></pre></td></tr></table></figure>

<h3 id="疏系数"><a href="#疏系数" class="headerlink" title="疏系数"></a>疏系数</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="punctuation">,</span>method<span class="operator">=</span><span class="punctuation">,</span>transform.pars<span class="operator">=</span><span class="punctuation">,</span>fixed<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">-</span>x<span class="operator">:</span>要进行模型拟合的序列名，</span><br><span class="line"><span class="operator">-</span>order<span class="operator">:</span></span><br><span class="line">指定模型阶数。order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>p为自回归阶数，d为差分阶数，q为移动平均阶数。</span><br><span class="line"><span class="operator">-</span>include<span class="punctuation">,</span>mean<span class="operator">:</span></span><br><span class="line">include.mean<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">,</span>需要拟合常数项；include.mean<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span>不需要拟合常数项，</span><br><span class="line"><span class="operator">-</span>method<span class="operator">:</span>指定参数估计方法，</span><br><span class="line"><span class="operator">-</span>transform<span class="punctuation">,</span>pars<span class="operator">:</span>指定参数估计是否由系统自动完成，</span><br><span class="line"><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span>transform.pars<span class="operator">=</span><span class="built_in">T</span><span class="operator">:</span>系统默认设置是系统根据order选项设置的模型阶数自动完成参数估计。</span><br><span class="line"><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span>transform<span class="punctuation">,</span>pars<span class="operator">=</span><span class="built_in">F</span><span class="operator">:</span>需要拟合疏系数模型，不能让系统根据模型的最高阶数自动完成所有参数的估计，我们需要进行人为干预，</span><br><span class="line"><span class="operator">-</span>fixed：对疏系数模型指定疏系数的位置。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若偏自相关图，除了1阶和4阶偏自相关系数显著大于2倍标准差，其他阶数的偏自相关系数基本都在2倍标差范围内波动，疏系数AR(1,4)</span></span><br><span class="line"><span class="comment"># 疏系数模型</span></span><br><span class="line"><span class="comment">## ARIMA((1,4),1,0)</span></span><br><span class="line">fit <span class="operator">&lt;-</span> arima<span class="punctuation">(</span>x<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>transform.pars<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span>fixed<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># transform.pars=F 人为干预</span></span><br><span class="line"><span class="comment">#fixed=c(NA,0,0,NA):只有1，4两个参数非零；2，3两个参数恒等于0</span></span><br><span class="line"><span class="comment">## # ARIMA(3,2,(1,2,6,7))</span></span><br><span class="line">g.fit4<span class="operator">&lt;-</span>arima<span class="punctuation">(</span>lng<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">)</span><span class="punctuation">,</span>transform.pars <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">,</span>fixed <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">,</span><span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="comment"># 包含了p的三个系数</span></span><br></pre></td></tr></table></figure>

<h2 id="移动平均提取趋势"><a href="#移动平均提取趋势" class="headerlink" title="移动平均提取趋势"></a>移动平均提取趋势</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单移动平均</span></span><br><span class="line"><span class="comment"># 简单移动平均就是将n个观测值的平均数作为第（n+1）/2个的拟合值。当n为偶数时，需进行二次移动平均。</span></span><br><span class="line">m4 <span class="operator">&lt;-</span> fliter<span class="punctuation">(</span>x<span class="operator">/</span><span class="number">5</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2*4复合移动平均</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先4（周期长度）</span></span><br><span class="line">m4 <span class="operator">&lt;-</span> fliter<span class="punctuation">(</span>x<span class="operator">/</span><span class="number">4</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 再2</span></span><br><span class="line">m2_4 <span class="operator">&lt;-</span> fliter<span class="punctuation">(</span>x4<span class="operator">/</span><span class="number">2</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span>sides<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># sides = 1或者2，“1”表示单边卷积，“2”表示双边卷积</span></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">dataframe<span class="punctuation">(</span>x<span class="punctuation">,</span>m2_4<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制移动效果</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>m2_4<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 残差序列图</span></span><br><span class="line"><span class="comment"># 原序列-趋势效应 = 季节效应+随机波动</span></span><br><span class="line">x_t <span class="operator">&lt;-</span> x<span class="operator">-</span>m2_4</span><br><span class="line">plot<span class="punctuation">(</span>x_t<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="加法季节"><a href="#加法季节" class="headerlink" title="加法季节"></a>加法季节</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x.t为剔除趋势效应的原序列</span></span><br><span class="line">x.t<span class="operator">&lt;-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 剔除缺失值，求总均值m</span></span><br><span class="line">m<span class="operator">&lt;-</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每个季节的均值ms</span></span><br><span class="line">ms <span class="operator">&lt;-</span> 0</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>k <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span>ms<span class="punctuation">[</span>k<span class="punctuation">]</span><span class="operator">=</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">[</span><span class="punctuation">,</span>k<span class="punctuation">]</span><span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 季节指数</span></span><br><span class="line">S<span class="operator">&lt;-</span>ms<span class="operator">-</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四个季节指数</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span>S<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机效应</span></span><br><span class="line">I<span class="operator">&lt;-</span>x<span class="operator">-</span>m2_4<span class="operator">-</span>S</span><br><span class="line">plot<span class="punctuation">(</span>I<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>



<h3 id="乘法模型"><a href="#乘法模型" class="headerlink" title="乘法模型"></a>乘法模型</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x.t为剔除趋势效应的原序列</span></span><br><span class="line">x.t<span class="operator">&lt;-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 剔除缺失值，求总均值m</span></span><br><span class="line">m<span class="operator">&lt;-</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每个季节的均值ms</span></span><br><span class="line">ms <span class="operator">&lt;-</span> 0</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>k <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span>ms<span class="punctuation">[</span>k<span class="punctuation">]</span><span class="operator">=</span>mean<span class="punctuation">(</span>x_t<span class="punctuation">[</span><span class="punctuation">,</span>k<span class="punctuation">]</span><span class="punctuation">,</span>na.rm<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 季节指数</span></span><br><span class="line">S<span class="operator">&lt;-</span>ms<span class="operator">/</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12个季节指数</span></span><br><span class="line">Month <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">12</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Month<span class="punctuation">,</span>S<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机效应</span></span><br><span class="line">I<span class="operator">&lt;-</span>x<span class="operator">/</span>m2_12<span class="operator">/</span>S</span><br><span class="line">plot<span class="punctuation">(</span>I<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="异方差模型"><a href="#异方差模型" class="headerlink" title="异方差模型"></a>异方差模型</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>moments<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rugarch<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>fGarch<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>FinTS<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#LM检验(拉格朗日乘子检验)</span></span><br><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span> print<span class="punctuation">(</span>ArchTest<span class="punctuation">(</span>lnr_d<span class="punctuation">,</span>lag<span class="operator">=</span>i<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># LM检验显示ARCH模型的P值均小于0.05，显著成立，这说明残差平方序列具有短期相关性，可以用ARCH模型提取残差平方序列中蕴含的相关关系。</span></span><br><span class="line"><span class="comment"># 拟合arch(1)模型</span></span><br><span class="line">spec2<span class="operator">&lt;-</span>ugarchspec<span class="punctuation">(</span>mean.model <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>armaOrder<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>include.mean<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">,</span>variance.model <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>garchOrder<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>model<span class="operator">=</span><span class="string">&quot;sGARCH&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>distribution.model<span class="operator">=</span><span class="string">&quot;norm&quot;</span><span class="punctuation">)</span></span><br><span class="line">fit4<span class="operator">&lt;-</span>ugarchfit<span class="punctuation">(</span>spec2<span class="punctuation">,</span>data<span class="operator">=</span>lnr_d<span class="punctuation">,</span>method<span class="operator">=</span><span class="string">&quot;ML&quot;</span><span class="punctuation">)</span></span><br><span class="line">fit4</span><br><span class="line">fit4<span class="operator">@</span>fit<span class="operator">$</span>matcoef</span><br><span class="line">plot<span class="punctuation">(</span>fit4<span class="punctuation">,</span>which<span class="operator">=</span><span class="number">8</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>fit4<span class="punctuation">,</span>which<span class="operator">=</span><span class="number">9</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>fit4<span class="punctuation">,</span>which<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>ylim<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">300</span><span class="punctuation">,</span><span class="number">300</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1.96</span><span class="operator">*</span>sd<span class="punctuation">(</span>lnr<span class="punctuation">)</span><span class="punctuation">,</span><span class="number">1.96</span><span class="operator">*</span>sd<span class="punctuation">(</span>lnr<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">fore <span class="operator">&lt;-</span> ugarchforecast<span class="punctuation">(</span>fit4<span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多元"><a href="#多元" class="headerlink" title="多元"></a>多元</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&#x27;TSA&#x27;</span><span class="punctuation">)</span></span><br><span class="line">arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span><span class="punctuation">,</span>xtransf<span class="operator">=</span><span class="punctuation">,</span>transfer<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#xreg:输入变量名（不需做函数转移）</span></span><br><span class="line"><span class="comment">#xtransf：输入变量名（需做函数转移）</span></span><br><span class="line"><span class="comment">#transfer：指定转移函数的模型阶数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#单变量不需要转移函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span>data.frame<span class="punctuation">(</span>x1<span class="punctuation">,</span>x2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#两变量不需要转移函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xtransf<span class="operator">=</span>x<span class="punctuation">,</span>transfer<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>m<span class="punctuation">,</span>n<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#单变量，ARMA(m,n)转移函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xtransf<span class="operator">=</span>data.frame<span class="punctuation">(</span>x1<span class="punctuation">,</span>x2<span class="punctuation">)</span><span class="punctuation">,</span>transfer<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>m1<span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span>m2<span class="punctuation">,</span>n2<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#双变量，分别ARMA(m,n)函数</span></span><br><span class="line"></span><br><span class="line">y.fit<span class="operator">=</span>arimax<span class="punctuation">(</span>y<span class="punctuation">,</span>order<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>p<span class="punctuation">,</span>d<span class="punctuation">,</span>q<span class="punctuation">)</span><span class="punctuation">,</span>xreg<span class="operator">=</span>x1<span class="punctuation">,</span>xtransf<span class="operator">=</span>x2<span class="punctuation">,</span>transfer<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>m<span class="punctuation">,</span>n<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#双变量，一个需要转移，一个不需要转移。</span></span><br><span class="line"></span><br><span class="line">x1<span class="operator">&lt;-</span>zlag<span class="punctuation">(</span>x<span class="punctuation">,</span>k<span class="punctuation">)</span></span><br><span class="line">x1<span class="operator">&lt;-</span>x1<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>k<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">y1<span class="operator">&lt;-</span>y<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>k<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#单变量，延迟k阶再ARMA(m,n)转移函数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>时间序列分析</category>
      </categories>
      <tags>
        <tag>时间序列分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS入门知识</title>
    <url>/2023/06/25/test/css%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p> 本博客介绍了CSS基本的用法，适合初学者入门学习。<span id="more"></span></p>
<p>reference:所有属性查找:<a href="https://www.w3school.com.cn/cssref/pr_align-content.asp">https://www.w3school.com.cn/cssref/pr_align-content.asp</a></p>
<h1 id="什么是css"><a href="#什么是css" class="headerlink" title="什么是css"></a>什么是css</h1><p>Cascading层叠<br>Style样式<br>Sheets列表</p>
<p>创建一个样式表</p>
<p>样式表分类：外部、内部、行内样式	</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>结构与样式分离的方式<br>便于后期维护与改版<br>可以用多套样式使网页有任意样式切换的效果</p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&#x27;css&#x27;&gt;</span><br><span class="line">p&#123;</span><br><span class="line">background-color:red;</span><br><span class="line">font-size:40px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>任何一个标签都可以作为样式选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归类选择器"><a href="#归类选择器" class="headerlink" title="归类选择器"></a>归类选择器</h3><p>class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p1&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;p class=“p1”&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>常用于超链接</p>
<p>选择整体</p>
<h4 id="a-link未访问的连接"><a href="#a-link未访问的连接" class="headerlink" title="a:link未访问的连接"></a>a:link未访问的连接</h4><h5 id="color"><a href="#color" class="headerlink" title="color"></a>color</h5><h4 id="a-visited已访问的连接"><a href="#a-visited已访问的连接" class="headerlink" title="a:visited已访问的连接"></a>a:visited已访问的连接</h4><h5 id="color-1"><a href="#color-1" class="headerlink" title="color"></a>color</h5><h4 id="hover鼠标悬停"><a href="#hover鼠标悬停" class="headerlink" title=":hover鼠标悬停"></a>:hover鼠标悬停</h4><p>不只是超链接</p>
<p>其他文本也可以用hover</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;--用于在鼠标悬停在类名为&quot;<span class="selector-class">.cart</span>&quot;的元素上时，对其子元素中类名为&quot;<span class="selector-class">.cart-list</span>&quot;的元素进行样式设置--&gt;</span><br><span class="line"><span class="selector-class">.cart</span><span class="selector-pseudo">:hover</span>&gt;<span class="selector-class">.cart-list</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">当鼠标悬停在搜索框 <span class="selector-tag">input</span> 上时，它的相邻元素 <span class="selector-tag">a</span> 的样式会改变，包括背景颜色、边框颜色和文字颜色等。</span><br><span class="line"><span class="selector-class">.search</span>&gt;<span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>+<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#b0b0b0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="active激活"><a href="#active激活" class="headerlink" title=":active激活"></a>:active激活</h4><p>点击的时候</p>
<h4 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h4><p>点击后，常用于文本录入提示</p>
<h3 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h3><h4 id="first-child"><a href="#first-child" class="headerlink" title=":first-child"></a>:first-child</h4><p>所有标签中第一个</p>
<h4 id="last-child"><a href="#last-child" class="headerlink" title=":last-child"></a>:last-child</h4><p>所有标签中最后一个</p>
<h4 id="nth-child"><a href="#nth-child" class="headerlink" title=":nth-child()"></a>:nth-child()</h4><p>选择特定的</p>
<h4 id="nth-last-child"><a href="#nth-last-child" class="headerlink" title=":nth-last-child()"></a>:nth-last-child()</h4><p>选择特定的 从最后一个开始算</p>
<p>:nth-last-child(2)</p>
<h4 id="first-of-type"><a href="#first-of-type" class="headerlink" title=":first-of-type"></a>:first-of-type</h4><p>选择一个上级元素下的第一个同类子元素</p>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>只不过伪元素多加了一个content属性，如果我们对他不进行设置，那么我们设置的伪元素就会不起作用，我们可以设置content的内容为一个空字符串</p>
<h4 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h4><p>选择指定元素中被用户选中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::selection&#123;</span><br><span class="line">background-color:red;&#125;</span><br><span class="line">&lt;!--选中则加红--&gt;</span><br></pre></td></tr></table></figure>

<h4 id="before"><a href="#before" class="headerlink" title="::before"></a>::before</h4><p>可以在内容之前插入新内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::before&#123;</span><br><span class="line">content:&quot;终于找到你&quot;;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h4><p>可以在内容之后插入新内容</p>
<h4 id="first-line"><a href="#first-line" class="headerlink" title="::first-line"></a>::first-line</h4><p>选择指定选择器的首行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-line&#123;</span><br><span class="line">background-color:yellow;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="first-letter"><a href="#first-letter" class="headerlink" title="::first-letter"></a>::first-letter</h4><p>选择文本的第一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-letter&#123;</span><br><span class="line">font-size:30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h3><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>不允许重复的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#name&#123;</span><br><span class="line">color:red</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">&lt;p class=&#x27;p1&#x27; id=&#x27;name&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通配符"><a href="#通配符" class="headerlink" title="*通配符"></a>*通配符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--默认所有统一的字体字号--&gt;</span><br><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="逗号选择器"><a href="#逗号选择器" class="headerlink" title="逗号选择器"></a>逗号选择器</h4><p>联合选择器</p>
<h4 id="空格选择器"><a href="#空格选择器" class="headerlink" title="空格选择器"></a>空格选择器</h4><p>子孙（后代）选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#div1 p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-选择器"><a href="#gt-选择器" class="headerlink" title="&gt;选择器"></a>&gt;选择器</h4><p>子选择器（不包含孙后代）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--不含在div1中div2，div3的范围--&gt;</span><br><span class="line">#div1&gt;p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="+兄弟选择器"></a>+兄弟选择器</h4><p>相邻兄弟选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--和div1同级别的p--&gt;</span><br><span class="line">#div1+p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="兄弟选择器-1"><a href="#兄弟选择器-1" class="headerlink" title="~兄弟选择器"></a>~兄弟选择器</h4><p>所有同级的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示某元素后所有同级的指定元素，选中的是所有的</span><br><span class="line">选中h2下面的所有p ： h2~p&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#btnScrollToTop:checked ~ #top &#123;</span><br><span class="line">  scroll-behavior: smooth;</span><br><span class="line">  scroll-margin-top: 100px; </span><br><span class="line">&#125;</span><br><span class="line">当复选框 #btnScrollToTop 处于选中状态（即被勾选）时，对具有 #top ID 的元素应用样式</span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title="[]"></a>[]</h4><p>属性选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p[class=&#x27;p1&#x27;]&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><h4 id="强制优先"><a href="#强制优先" class="headerlink" title="强制优先"></a>强制优先</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">background-coLor:yellow!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同级别"><a href="#同级别" class="headerlink" title="同级别"></a>同级别</h4><p>后出现的会覆盖之前的设置</p>
<h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p> 1<br>!important<br>2<br>行内样式<br>3<br>ID选择器<br>4<br>类选择器<br>5<br>标签<br>6<br>通配符<br>7<br>浏览器默认属性</p>
<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.price2&gt;del&#123;</span><br><span class="line">    color: #b0b0b0;</span><br><span class="line">    margin-left: 6px;</span><br><span class="line">&#125;</span><br><span class="line">对类名为&quot;.price2&quot;的元素下的&quot;del&quot;标签进行样式设置:删除线</span><br></pre></td></tr></table></figure>



<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="背景background"><a href="#背景background" class="headerlink" title="背景background"></a>背景background</h3><h4 id="background-color：背景颜色"><a href="#background-color：背景颜色" class="headerlink" title="background-color：背景颜色"></a>background-color：背景颜色</h4><h4 id="background-image：背景图片"><a href="#background-image：背景图片" class="headerlink" title="background-image：背景图片"></a>background-image：背景图片</h4><h4 id="background-repeat：重复方向"><a href="#background-repeat：重复方向" class="headerlink" title="background-repeat：重复方向"></a>background-repeat：重复方向</h4><h4 id="background-attachment：背景是否随滚动条滚动"><a href="#background-attachment：背景是否随滚动条滚动" class="headerlink" title="background-attachment：背景是否随滚动条滚动"></a>background-attachment：背景是否随滚动条滚动</h4><h4 id="background-position：背景图片的起始位置"><a href="#background-position：背景图片的起始位置" class="headerlink" title="background-position：背景图片的起始位置"></a>background-position：背景图片的起始位置</h4><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="color文本颜色"><a href="#color文本颜色" class="headerlink" title="color文本颜色"></a>color文本颜色</h4><h4 id="direction文本方向"><a href="#direction文本方向" class="headerlink" title="direction文本方向"></a>direction文本方向</h4><p>ltr、rtl(对阿拉伯数字和符号有效，逆序)</p>
<h4 id="letter-spacing字符间距"><a href="#letter-spacing字符间距" class="headerlink" title="letter-spacing字符间距"></a>letter-spacing字符间距</h4><p>npx</p>
<h4 id="line-height行高"><a href="#line-height行高" class="headerlink" title="line-height行高"></a>line-height行高</h4><p>npx</p>
<h4 id="text-align文本对齐"><a href="#text-align文本对齐" class="headerlink" title="text-align文本对齐"></a>text-align文本对齐</h4><p>left</p>
<p>right</p>
<p>center</p>
<p>justify两端对齐 </p>
<h4 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h4><p>underline下划线</p>
<p>overline</p>
<p>line-through</p>
<h4 id="text-shadow阴影"><a href="#text-shadow阴影" class="headerlink" title="text-shadow阴影"></a>text-shadow阴影</h4><p>5px 5px 10px red </p>
<h4 id="text-transform字母大小写"><a href="#text-transform字母大小写" class="headerlink" title="text-transform字母大小写"></a>text-transform字母大小写</h4><p>capitalize</p>
<p>uppercase</p>
<p>lowercase</p>
<h4 id="text-indent首行缩进"><a href="#text-indent首行缩进" class="headerlink" title="text-indent首行缩进"></a>text-indent首行缩进</h4><p>npx</p>
<p>nem（字符数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;--!法1--&gt;</span><br><span class="line">top left</span><br><span class="line">tap center</span><br><span class="line">top right</span><br><span class="line">center left</span><br><span class="line">center center</span><br><span class="line">center right</span><br><span class="line">bottom left</span><br><span class="line">bottom center</span><br><span class="line">bottom right</span><br><span class="line">&lt;--!法2--&gt;</span><br><span class="line">x% y%</span><br><span class="line">&lt;--!法3--&gt;</span><br><span class="line">xpos ypos</span><br></pre></td></tr></table></figure>

<h4 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h4><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">clip</td>
<td align="left">修剪文本。</td>
</tr>
<tr>
<td align="left">ellipsis</td>
<td align="left">显示省略符号来代表被修剪的文本。</td>
</tr>
<tr>
<td align="left"><em>string</em></td>
<td align="left">使用给定的字符串来代表被修剪的文本。</td>
</tr>
</tbody></table>
<h3 id="列表-list-style"><a href="#列表-list-style" class="headerlink" title="列表 list-style"></a>列表 list-style</h3><p>list-style:none列表数字没有了。</p>
<h4 id="list-style-type"><a href="#list-style-type" class="headerlink" title="list-style-type"></a>list-style-type</h4><p>disc<br>circle<br>square<br>decimal<br>decimal-leading-zero<br>lower-roman<br>upper-roman<br>lower-alpha<br>upper-alpha<br>lower-greek<br>lower-latin<br>upper-latin</p>
<h4 id="list-style-position"><a href="#list-style-position" class="headerlink" title="list-style-position"></a>list-style-position</h4><p>outside</p>
<h4 id="list-style-image"><a href="#list-style-image" class="headerlink" title="list-style-image"></a>list-style-image</h4><p>url(“image.png”)</p>
<h3 id="字体font"><a href="#字体font" class="headerlink" title="字体font"></a>字体font</h3><h4 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h4><p>隶书；宋体</p>
<h4 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h4><p>italic部分斜体</p>
<p>oblique所有字体都可以斜体</p>
<h4 id="font-weight粗细"><a href="#font-weight粗细" class="headerlink" title="font-weight粗细"></a>font-weight粗细</h4><p>bold、100-900中的数字</p>
<h4 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h4><p>npx</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h4><p>pointer;pointer小手</p>
<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><p>all .2s;</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="/images%5C1687228184834.png" alt="1687228184834"></p>
<h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><h3 id="height"><a href="#height" class="headerlink" title="height"></a>height</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">background-color:yellow;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">position:absolute;</span><br><span class="line">top:200px;</span><br><span class="line">Left:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置好div容器的大小</p>
<p>若有图片或文字溢出，该怎么办</p>
<ol>
<li>超出dv宽度高度的文字或图片进行隐藏处理</li>
<li>超出dv宽度高度的文字或图片增加滚动条</li>
</ol>
<h3 id="溢出overflow"><a href="#溢出overflow" class="headerlink" title="溢出overflow"></a>溢出overflow</h3><p>visible默认值。内容不会被修剪，会呈现在元素框之外。</p>
<p>hidden超出的部分被隐藏。</p>
<p>scroll不论是否需要，都显示滚动条。</p>
<p>auto按需显示滚动条以便查看其余的内容。</p>
<p>轮廓outline:dashed(虚线) dotted（点状轮廓）solid（实线）double（双线）</p>
<h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><p>border:1px solid black</p>
<h4 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h4><h5 id="border-left"><a href="#border-left" class="headerlink" title="border-left"></a>border-left</h5><h5 id="border-right"><a href="#border-right" class="headerlink" title="border-right"></a>border-right</h5><h5 id="border-top"><a href="#border-top" class="headerlink" title="border-top"></a>border-top</h5><h5 id="border-bottom"><a href="#border-bottom" class="headerlink" title="border-bottom"></a>border-bottom</h5><p>solid，none, double</p>
<h4 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a>border-style</h4><p>上右底左</p>
<p>none: 默认无边框</p>
<p>dotted: 定义一个点线边框</p>
<p>dashed: 定义一个虚线边框</p>
<p>solid: 定义实线边框</p>
<p>double: 定义两个边框。 两个边框的宽度和 border-width 的值相同</p>
<p>groove: 定义3D沟槽边框。效果取决于边框的颜色值</p>
<p>ridge: 定义3D脊边框。效果取决于边框的颜色值</p>
<p>inset:定义一个3D的嵌入边框。效果取决于边框的颜色值</p>
<p>outset: 定义一个3D突出边框。 效果取决于边框的颜色值</p>
<h4 id="border-color"><a href="#border-color" class="headerlink" title="border-color"></a>border-color</h4><h4 id="border-box"><a href="#border-box" class="headerlink" title="border-box:"></a>border-box:</h4><p>已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度</p>
<h4 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h4><p>50% 变成圆形</p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>文字到div的距离</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><h4 id="left"><a href="#left" class="headerlink" title="left"></a>left</h4><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>div到其他部分的距离</p>
<h4 id="margin-top"><a href="#margin-top" class="headerlink" title="margin-top"></a>margin-top</h4><h4 id="margin-left"><a href="#margin-left" class="headerlink" title="margin-left"></a>margin-left</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin:25px 50px 75px 100px;</span><br><span class="line">上边距为25px</span><br><span class="line">右边距为50px</span><br><span class="line">下边距为75px</span><br><span class="line">左边距为100px</span><br><span class="line"></span><br><span class="line">margin:25px 50px 75px;</span><br><span class="line">上边距为25px</span><br><span class="line">左右边距为50px</span><br><span class="line">下边距为75px</span><br><span class="line"></span><br><span class="line">margin:25px 50px;</span><br><span class="line">上下边距为25px</span><br><span class="line">左右边距为50px</span><br><span class="line"></span><br><span class="line">margin:25px;</span><br><span class="line">所有的4个边距都是25px</span><br><span class="line"></span><br><span class="line">auto	设置浏览器边距。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="box"><a href="#box" class="headerlink" title="box"></a>box</h3><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing:"></a>box-sizing:</h4><p>padding的距离由哪产生</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">content-box</td>
<td align="left">默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</td>
</tr>
<tr>
<td align="left">border-box</td>
<td align="left">告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减 去(border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 <strong>注：</strong>border-box 不包含 margin。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">指定 box-sizing 属性的值，应该从父元素继承</td>
</tr>
</tbody></table>
<h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>2px 2px 10px #7d7d7d insert;</p>
<p>灰色，内阴影</p>
<h1 id="脱标流"><a href="#脱标流" class="headerlink" title="脱标流"></a>脱标流</h1><p>文档流：</p>
<p>空白折叠现象（换行就会有空格 不换行就没有）<br>高矮不齐，底边对齐<br>自动换行，一行写满，换行写</p>
<p>脱标流</p>
<h2 id="float："><a href="#float：" class="headerlink" title="float："></a>float：</h2><p>left：向页面最左边左浮动</p>
<p>下面一层忽略float的</p>
<p>right</p>
<p>none</p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>both</p>
<p>黑色部分清除浮动</p>
<p>不再浮动</p>
<p>本来应该被盖在浮动的下面的会另起一行</p>
<p>不会被覆盖了</p>
<p><img src="/images%5C1687243725372.png" alt="1687243725372"></p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#clearDiv:after&#123;</span><br><span class="line">content:&quot;&quot;;</span><br><span class="line">visibility:hidden;</span><br><span class="line">height:0px;</span><br><span class="line">display:block;</span><br><span class="line">clear:·both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=&#x27;clearDiv&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="子元素与父元素"><a href="#子元素与父元素" class="headerlink" title="子元素与父元素"></a>子元素与父元素</h1><p>不指定宽度，默认整个屏幕</p>
<p>不指定高度，默认为0；</p>
<p>指定子元素高度，默认父元素也是那么高。</p>
<p>当子元素为float，则不同步。</p>
<h1 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>不会改变原来的坑，只是网页渲染位置变化</p>
<p>用来微调位置</p>
<h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>绝对坐标定位</p>
<p>默认以网页作为起始点</p>
<p>脱离了标准文档流，对其他元素进行压盖。</p>
<p>应用：轮播图</p>
<p>left到左边的距离；rights到右边的距离；top到上边的距离；bottom到下边的距离</p>
<p>left，right只用一个</p>
<p>top，bottom也只用一个。</p>
<p>如果是父元素是relative或者absolute，那么以父元素为起始点。（子固父相）</p>
<h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>固定定位</p>
<p>脱离标准文档流</p>
<p>应用：返回顶部</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>相对自己原来的或者坐标描述</p>
<h3 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h3><p>向下</p>
<h3 id="left-1"><a href="#left-1" class="headerlink" title="left"></a>left</h3><h3 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h3><p>向上</p>
<h3 id="right"><a href="#right" class="headerlink" title="right"></a>right</h3><h2 id="应用：居中"><a href="#应用：居中" class="headerlink" title="应用：居中"></a>应用：居中</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width:400px;</span><br><span class="line">height:300px;</span><br><span class="line">border:1px solid #000;</span><br><span class="line">margin:40px auto;</span><br><span class="line">position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p&#123;</span><br><span class="line">width:80px;</span><br><span class="line">height:80px;</span><br><span class="line">background-color:Dorange;</span><br><span class="line">position:absolute;</span><br><span class="line">top:50%</span><br><span class="line">margin-top:-40px;</span><br><span class="line">left:50%;</span><br><span class="line">margin-left:-40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>



<h1 id="行内和块级的转换display"><a href="#行内和块级的转换display" class="headerlink" title="行内和块级的转换display"></a>行内和块级的转换display</h1><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>元素转为块级元素</p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>可将元素转为行内元素</p>
<h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>将元素转为行内块</p>
<h1 id="元素的隐藏"><a href="#元素的隐藏" class="headerlink" title="元素的隐藏"></a>元素的隐藏</h1><p>使用display:none;<br>可以将元素隐藏，元素将彻底放弃位置，如同没有写它的标签一样.</p>
<p>使用visibility:hidden;<br>可以也可以将元素隐藏，但是元素不放弃自己的位置。（页面上看到的是白色的方块，方块大小和原来的元素大小一样）</p>
<h1 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h1><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>数值越大，越在顶层</p>
<p>弹性布局</p>
<h2 id="指定flex布局"><a href="#指定flex布局" class="headerlink" title="指定flex布局"></a>指定flex布局</h2><p>display:flex(块级元素)</p>
<p>display:inline-flex(内连块)</p>
<h2 id="flex相关名词"><a href="#flex相关名词" class="headerlink" title="flex相关名词"></a>flex相关名词</h2><p>flex容器里的子元素叫做flex项目</p>
<p>只要有子元素 就可以当作是容器</p>
<p>主轴 交叉轴</p>
<p><img src="/images%5C1687306433055.png" alt="1687306433055"></p>
<p>flex项目沿着主轴方向放置</p>
<h2 id="flex容器的属性"><a href="#flex容器的属性" class="headerlink" title="flex容器的属性"></a>flex容器的属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction:"></a>flex-direction:</h3><p>定义主轴<br>row默认值：默认水平方向从左到右为主轴<br>row-reverse:水平方向从右到左为主轴<br>column:垂直方向从上到下为主轴<br>column-reverse:垂直方向从下到上为主轴</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>定义了如果一条轴线排不下，如何<strong>换行</strong></p>
<p>nowrap默认值直：默认不换行<br>wrap:换行<br>wrap-reverse:不仅换行还改变了默认方向，元素从下到上排列</p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-direction和flex-wrap的简写形式</p>
<p>flex-flow:row wrap</p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>定义了flex项目在主轴上的对齐方式</p>
<p>flex-start(默认值)：默认从行首起始位置开始排列(左对齐)<br>flex-end:从行尾位置开始排列(右对齐)<br>center:居中排列<br>space-between:均匀排列每个元素。首个元素放置于起点，末尾元素放置于终点(均匀排列 首位无间隙)<br>space-around:均匀排列每个元素。每个元素周围分配相同的空间(均匀排列 首位空)</p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>定义了Flex项目在交叉轴上如何对齐</p>
<p>stretch默认值：默认弹性元素被在交叉轴方向被<strong>拉伸</strong>到与容器相同的高度或宽度(占满容器)<br>flex-start:元素向交叉轴起点对齐<br>flex-end:元素向交叉轴终点对齐<br>center:元素在交叉轴居中<br>baseline:所有元素向基线对齐</p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>定义了存在多根主轴线时，Flex项目在交叉轴上如何对齐<br>stretch(默认)：默认拉伸所有行来填满剩余空间<br>flex-start:从起始点开始放置元素<br>flex-end:从终止点开始放置元素<br>center:将元素放置在中点<br>space-between:均匀分布项目。第一项与起始点齐平，最后一项与终止点齐平<br>space-around:均匀分布项目。项目在两端有一半大小的空间</p>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>flex项目的排列顺序</p>
<p>越小越在前面</p>
<p>默认是0</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>放大比例</p>
<p>默认是0，也不会放大，正常排</p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话)（会放大）</p>
<p><img src="/images%5C1687308113459.png" alt="1687308113459"></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>缩小比例0&#x2F;1</p>
<p>如果所有项目的fIex-shrink属性都不为0，当空间不足时，都将等比例缩小</p>
<p>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>在分配多余空间之前，Flex项目占据的主轴大小(main size)</p>
<p>auto</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>fIex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</p>
<p>align-self:</p>
<p>auto（默认值）</p>
<p>flex-start</p>
<p>flex-end </p>
<p>center</p>
<p>stretch </p>
<p>baseline;</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p><img src="/images%5C1687308826154.png" alt="1687308826154"></p>
]]></content>
      <categories>
        <category>css</category>
        <category>网页制作</category>
      </categories>
  </entry>
  <entry>
    <title>从0开始的pytorch环境配置</title>
    <url>/2023/10/15/test/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84pytorch%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="从0开始的pytorch环境配置"><a href="#从0开始的pytorch环境配置" class="headerlink" title="从0开始的pytorch环境配置"></a>从0开始的pytorch环境配置</h1><p>前言：对电脑刷机了，装好了anaconda，但是环境还没配。炼丹必备<span id="more"></span></p>
<h2 id="gpu相关的"><a href="#gpu相关的" class="headerlink" title="gpu相关的"></a>gpu相关的</h2><ol>
<li><p>查看显卡：任务管理器查看是否有英伟达显卡</p>
</li>
<li><p>在官网查看自己的显卡是否支持 CUDA 安装<br>NVIDIA官网地址：<a href="https://developer.nvidia.com/cuda-gpus">https://developer.nvidia.com/cuda-gpus</a></p>
</li>
<li><p>查看自己的显卡驱动版本<br>命令行输入以下命令</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NVIDIA-SMI</span><br></pre></td></tr></table></figure>

<p>如果没有，请将C:\Program Files\NVIDIA Corporation\NVSMI文件夹放置系统路径的path之中</p>
<ol start="4">
<li>升级显卡驱动程序</li>
</ol>
<p>去Nvidia官网地址 <a href="https://links.jianshu.com/go?to=https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a> 按系统版本，选择下载在线升级包, 下载完后，选择<strong>自定义</strong>先升级显卡驱动,如图:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/28789528-198feb5cb4e4e010.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/582/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/28789528-03be5475ba381a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590/format/webp" alt="img"></p>
<ol start="5">
<li>CUDA安装是否成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<h2 id="python环境安装"><a href="#python环境安装" class="headerlink" title="python环境安装"></a>python环境安装</h2><p>1.定义环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n mytorch python==3.9</span><br></pre></td></tr></table></figure>
<p>2.运行环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate mytorch</span><br></pre></td></tr></table></figure>
<p>3.安装<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a><br>pytorch：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install pytorch==2.0.0 torchvision==0.15.0 torchaudio==2.0.0 pytorch-cuda=11.8 -c pytorch -c nvidia -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>4.测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%进入python环境 </span><br><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir(torch)</span><br><span class="line">help(torch.cuda.is_available)</span><br></pre></td></tr></table></figure>
<p>5.jupyter编辑器<br>Anaconda Prompt<br>输入指令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate mytorch</span><br><span class="line">jupyter notebook</span><br><span class="line">#打开jupyter后</span><br><span class="line">import torch</span><br></pre></td></tr></table></figure>
<p>6.查看和删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境的查看</span><br><span class="line">Anaconda Prompt</span><br><span class="line">conda info -e   </span><br><span class="line">环境的删除</span><br><span class="line">conda remove --name yolo5 --all</span><br></pre></td></tr></table></figure>

<p>8.一些镜像源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install tensorflow-cpu==2.3.0 </span><br><span class="line">-i https://mirror.baidu.com/pypi/simple</span><br><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">-i http://pypi.douban.com/simple/</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>Could not find a version that satisfies the requirement<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install &lt;库名&gt;			安装</span><br><span class="line">pip uninstall &lt;库名&gt;		卸载</span><br><span class="line">pip install -U &lt;库名&gt;		更新</span><br><span class="line">pip download &lt;库名&gt;			只下载，不安装</span><br><span class="line">pip show &lt;库名&gt;				展示这个库的信息</span><br><span class="line">pip search &lt;库名&gt;			搜索关键字</span><br><span class="line">pip list				列出安装的库</span><br><span class="line">查看用conda安装的包：</span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>python</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>关于乒乓球</title>
    <url>/2023/03/02/test/%E4%B9%92%E4%B9%93%E7%90%83%E8%AE%AD%E7%BB%83%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>本文为博主自己练习乒乓球时的碎碎念，博主十分高兴能够找到一个能够坚持的体育爱好。</p>
<span id="more"></span>

<h1 id="乒乓球训练日记"><a href="#乒乓球训练日记" class="headerlink" title="乒乓球训练日记"></a>乒乓球训练日记</h1><ol>
<li><p>今晚练习乒乓球，这种性格上的改变好像影响了我的乒乓球风格。正手好像是找到了腿和身体和手的协调统一，反手的进步或许源于还原的意识更强烈。通过看视频，我更注重自己身体要稳定，不能散掉。前后的步伐还有待加强。发球的旋转仍然是困难的。</p>
</li>
<li><p>反手的重心要压低一点，要用身体发力的动作。</p>
</li>
<li><p>正手打球的时候太急了一点。</p>
</li>
<li><p>打比赛的时候精神信念，要专注于比赛本身，敢于发力，精神集中。不要觉得自己很弱不敢打，对待好每个球，要有一些自己的判断，不能瞎打。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>乒乓球</category>
      </categories>
      <tags>
        <tag>乒乓球</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/29/test/hello-world/</url>
    <content><![CDATA[<p>Hello World！</p>
<p>这里是老约翰的世界。欢迎。</p>
]]></content>
  </entry>
  <entry>
    <title>数据库重点内容</title>
    <url>/2023/03/24/test/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>交互式SQL和嵌入式SQL</p>
<p>独立使用SQL语言进行数据库操作时，其使用方法称为交互式SQL，独立使用SQL语言进行数据库操作时，其使用方法称为交互式SQL</p>
<p>当一个程序既要访问数据库，又要处理数据时，把SQL语言嵌入程序设计语言即宿主语言中，将SQL语言访问数据库的功能和宿主语言的数据处理功能相结合，是目前解决该问题的最有效途径。</p>
<span id="more"></span>

<h1 id="一、数据-相关概念"><a href="#一、数据-相关概念" class="headerlink" title="一、数据..相关概念"></a>一、数据..相关概念</h1><p>数据库中储存的是<strong>数据与数据的联系</strong></p>
<p><strong>长期储存</strong>在计算机内、<strong>有组织的</strong>、<strong>可共享的</strong>数据集合</p>
<h2 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h2><p>社交网络数据库<br>电子商务平台数据库<br>企业信息数据库<br>通讯数据库</p>
<p>数据库中的数据可以共享</p>
<p>数据库减少了数据冗余</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数值、图形、文本、音频…..</p>
<h2 id="数据-DATA-储存方式"><a href="#数据-DATA-储存方式" class="headerlink" title="数据(DATA)储存方式"></a>数据(DATA)储存方式</h2><p>写在纸上的，存在excel表格的…</p>
<ul>
<li>本节课的数据库（DB）特指长期储存在计算机内、有组织的、可共享的数据集合。</li>
</ul>
<h2 id="数据库管理系统（DBMS）-Mysql"><a href="#数据库管理系统（DBMS）-Mysql" class="headerlink" title="数据库管理系统（DBMS）- Mysql"></a>数据库管理系统（DBMS）- Mysql</h2><p>SQL 语言集数据定义 、数据查询  、数据操纵、数据控制功能于一体。 </p>
<ul>
<li>数据库管理系统<strong>是位于用户与操作系统之间</strong>的一层数据管理软件</li>
<li>目标：科学地组织和存储数据、高效地获取和维护数据</li>
<li>位于用户应用与操作系统之间的一层数据管理软件</li>
<li>属于基础软件，是一个大型复杂的软件系统。</li>
<li>一组系统软件，而不是一组应用软件。</li>
</ul>
<h3 id="数据定义DDL"><a href="#数据定义DDL" class="headerlink" title="数据定义DDL"></a>数据定义DDL</h3><p>提供数据定义语言(DDL)，用于定义数据库中的数据对象</p>
<p>语言：DDL</p>
<h3 id="数据操作-x2F-数据操控DML"><a href="#数据操作-x2F-数据操控DML" class="headerlink" title="数据操作&#x2F;数据操控DML"></a>数据操作&#x2F;数据操控DML</h3><p>提供数据操纵语言(DML)，用于操纵数据实现对数据库的基本操作(查询、插入、删除和修改)</p>
<p><strong>增删改查</strong></p>
<p>语言：DML</p>
<h3 id="数据库控制"><a href="#数据库控制" class="headerlink" title="数据库控制"></a>数据库控制</h3><p>语言：</p>
<h3 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h3><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>对外连接</p>
<h2 id="数据库管理员（DBA）"><a href="#数据库管理员（DBA）" class="headerlink" title="数据库管理员（DBA）"></a>数据库管理员（DBA）</h2><p>负责全面管理和控制数据库系统，是数据库系统中最重要的人员。<br>职责（我们的学习目标）：</p>
<ul>
<li>设计和定义数据库系统</li>
<li>帮助最终用户使用数据库系统</li>
<li>监督与控制数据库系统的使用和运行</li>
<li>改进和重组数据库系统</li>
<li>调优数据库系统的性能</li>
<li>转储和恢复数据库</li>
<li>重构数据库</li>
</ul>
<h2 id="数据库系统（DBS）"><a href="#数据库系统（DBS）" class="headerlink" title="数据库系统（DBS）"></a>数据库系统（DBS）</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>①数据<strong>结构化</strong><br>②数据的共享性高，<strong>冗余度低</strong>，且容易扩充。<br>③数据<strong>独立性</strong>高(物理独立性（应用程序与物理存储相互独立，数据的物理存储改变应用程序不改变),（逻辑独立性人应用程序与逻辑结构相互独立，数据的逻辑结构改变应用程序不改变）<br>④数据由数据库管理系统<strong>统一管理和控制</strong></p>
<p>在DBS中，DBMS调用了OS的功能。</p>
<p>数据共享，数据独立性高，数据完整性，减少了数据冗余。</p>
<p>应用数据库技术的主要目的是为了共享数据问题。</p>
<p>在计算机系统中引入数据库后的系统构成</p>
<p>数据库系统的构成：</p>
<ul>
<li>数据库</li>
<li>数据库管理系统</li>
<li>应用系统（及其开发工具）</li>
<li>相关人员（数据库管理员、应用系统开发人员、用户）</li>
</ul>
<p>概括： 硬件、软件(DBMS运行的操作系统和本身)、数据库、用户</p>
<h2 id="应用系统"><a href="#应用系统" class="headerlink" title="应用系统"></a>应用系统</h2><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h2 id="应用开发软件"><a href="#应用开发软件" class="headerlink" title="应用开发软件"></a>应用开发软件</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>数据库中，产生数据不一致的根本原因是数据冗余</p>
<p><strong>主要原因是事务的隔离性在并发中遭到了破坏</strong></p>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>数据模型是数据库系统的<strong>核心和基础</strong></p>
<p>在数据库中用数据模型这个工具来抽象、表示和处理现实世界中的数据和信息。通俗地讲数据模型就是现实世界的模拟。例如：地图、航模飞机。</p>
<p>数据模型应满足三方面要求<br>能比较真实地模拟现实世界<br>容易为人所理解<br>便于在计算机上实现。</p>
<p>将E-R模型转换成关系模型，属于数据库的逻辑设计。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>现实世界 –&gt; 概念模型 –&gt; 逻辑模型 –&gt; 物理模型 –计算机中数据</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>信息模型</p>
<p>它是<strong>面向用户的模型</strong>，是现实世界到机器世界的一个中间层次。其基本特征是按用户观点对信息进行建模，<strong>与具体DBMS无关。</strong></p>
<p>世界是由一组称作实体的基本对象和这些对象之间的联系构成。</p>
<h4 id="E-R模型："><a href="#E-R模型：" class="headerlink" title="E-R模型："></a>E-R模型：</h4><p>独立于<strong>计算机系统</strong>的模型</p>
<p>实体－联系方法<br>（1）<strong>实体</strong>（Entity）。实体是指客观存在并可相互区别的事物。实体可以是人、事或物，也可以是抽象的概念。如一件商品、一个客户、一份订单等都是实体。</p>
<p>关系模型中实现实体间 N：M 联系是通过增加一个<strong>关系实现</strong>。</p>
<p>（2）<strong>属性</strong>（Attribute）。实体通常有若干特征，每个特征称为实体的一个属性。属性刻画了实体在某方面的特性。例如，商品实体的属性可以有商品编号、商品类别、商品名称、生产商等。<br>（3）<strong>联系</strong>（Relationship）。现实世界中事物之间的联系反映在E-R模型中就是<strong>实体间的联系</strong>。例如，订单就是客户和商品之间的联系。</p>
<h5 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h5><p>实体用矩形框表示，属性用椭圆形框表示，联系用菱形框表示,实体与属性与联系之间用无向直线连接。</p>
<h4 id="概念模型的用途"><a href="#概念模型的用途" class="headerlink" title="概念模型的用途"></a>概念模型的用途</h4><p>概念模型用于信息世界的建模<br>是现实世界到机器世界的一个中间层次<br>是数据库设计的有力工具<br>数据库设计人员和用户之间进行交流的语言</p>
<h4 id="对概念模型的基本要求"><a href="#对概念模型的基本要求" class="headerlink" title="对概念模型的基本要求"></a>对概念模型的基本要求</h4><p>较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识<br>简单、清晰、易于用户理解。</p>
<h4 id="转表"><a href="#转表" class="headerlink" title="转表"></a>转表</h4><p>如果两个实体之间具有 m：n 联系，则将它们转换为关系模型的结果是3个表。</p>
<h3 id="逻辑模型（数据模型）"><a href="#逻辑模型（数据模型）" class="headerlink" title="逻辑模型（数据模型）"></a>逻辑模型（数据模型）</h3><p>大多数时候就直接称为数据模型</p>
<p>由DBMS支持的</p>
<h4 id="三要素1：数据结构"><a href="#三要素1：数据结构" class="headerlink" title="三要素1：数据结构"></a>三要素1：数据结构</h4><p>静态特性，数据本身以及数据之间的联系。<br>刻画数据模型性质的重要方面。<br>通常采用数据结构的类型来命名数据模型。</p>
<h5 id="关系模型（主流）"><a href="#关系模型（主流）" class="headerlink" title="关系模型（主流）"></a>关系模型（主流）</h5><p>基本的数据结构是表格，关系模型使用<strong>二维表</strong>来表示实体及其联系。<br>关系模型的数据操作主要包括查询和更新。关系数据操作具有两个显著特点：一是关系操作是集合操作，即操作的对象和结果均为集合；二是关系模型将操作中的存取路径向用户屏蔽起来，用户只要说明做什么，而不必指出怎样做。</p>
<h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>网状（可以多根）（多个父亲）</p>
<p>允许两个结点间有多种联系（复合联系）</p>
<h5 id="层次模型-树状"><a href="#层次模型-树状" class="headerlink" title="层次模型-树状"></a>层次模型-树状</h5><p>（一个根）（一个联系）</p>
<h5 id="面向对象模型-Object-Oriented-Model）"><a href="#面向对象模型-Object-Oriented-Model）" class="headerlink" title="面向对象模型*(Object Oriented Model）"></a>面向对象模型*(Object Oriented Model）</h5><h5 id="对象关系模型-Object-Relational-Model"><a href="#对象关系模型-Object-Relational-Model" class="headerlink" title="对象关系模型*(Object Relational Model)"></a>对象关系模型*(Object Relational Model)</h5><h4 id="三要素2：数据操作"><a href="#三要素2：数据操作" class="headerlink" title="三要素2：数据操作"></a>三要素2：数据操作</h4><p>数据操作指对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则，它是对数据库动态特性的描述。<br>数据库中的数据操作主要分为查询、更新两大类，其中数据更新主要是指对数据记录的增、删、改。<br>数据模型需要定义这些操作的语义、操作符号、操作规则及实现操作的相关语句。 </p>
<p>动态特征，允许执行的操作的集合，包括操作及操作规则。一般有检索、更新(插入、副除、修改)操作。</p>
<h4 id="三要素3：数据完整性约束"><a href="#三要素3：数据完整性约束" class="headerlink" title="三要素3：数据完整性约束"></a>三要素3：数据完整性约束</h4><p>完整性约束是数据的一组完整性规则的集合。<br>完整性规则是给定的数据模型中数据及其联系所具有的制约和存储规则，用以限定符合数据模型的数据库状态以及状态的变化，保证数据的正确、有效、相容。 </p>
<p>是完整性规则的集合，规定数据库状态及状态变化所应满足的条件。</p>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>在数据库系统阶段，数据和程序之间具有较高的独立性。</p>
<h1 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h1><p>目的：提高数据和程序的独立性。</p>
<ul>
<li>系统模式的概念:<ul>
<li>模式（Schema）<br>  是对数据库逻辑结构和特征的描述是型的描述，<strong>不涉及具体值</strong>模式是相对稳定的</li>
<li>实例（Instance）<br>  数据库某一时刻的状态——<strong>模式的一个具体值</strong>同一个模式可以有很多实例,实例随数据库中的数据的更新而变动</li>
</ul>
</li>
</ul>
<h2 id="三级模式：（外模式、模式、内模式）"><a href="#三级模式：（外模式、模式、内模式）" class="headerlink" title="三级模式：（外模式、模式、内模式）"></a>三级模式：（外模式、模式、内模式）</h2><p>这是数据库开发人员的角度，是内部结构。三级模式是对数据的三个抽象级别</p>
<h3 id="外模式（视图）-子模式）（用户模式-："><a href="#外模式（视图）-子模式）（用户模式-：" class="headerlink" title="外模式（视图）(子模式）（用户模式)："></a>外模式（视图）(子模式）（用户模式)：</h3><p>视图是存放在数据库的表，为了安全。视图可以有多个，代表<strong>外模式也可以有多个</strong>。</p>
<p>数据库用户使用的<u>局部数据的逻辑结构和特征的描述</u></p>
<p>外模式通常是<strong>模式的子集</strong>、一个模式可以有多个外模式反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求。每个用户只能看见和访问所对应的外模式中的数据，简化<strong>用户视图</strong>。</p>
<p><strong>单个用户使用的数据视图的描述称为“外模式”。</strong></p>
<h3 id="模式（基本表）-逻辑模式-："><a href="#模式（基本表）-逻辑模式-：" class="headerlink" title="模式（基本表）(逻辑模式)："></a>模式（基本表）(逻辑模式)：</h3><p>一个数据库只有<strong>一个模式</strong></p>
<p>模式是数据库系统模式结构的中心</p>
<p>数据库全体数据的逻辑结构和特征的描述，所有用户的公共数据视图。</p>
<p>这里的基本表并不是指你创建的表，而是本身存放在数据库的基本表，它们构成了一套逻辑结构来代表模式。</p>
<p>与数据的物理存储细节和硬件环境无关、与具体的应用程序、开发工具及高级程序设计语言无关。</p>
<h3 id="内模式（存储模式）："><a href="#内模式（存储模式）：" class="headerlink" title="内模式（存储模式）："></a>内模式（存储模式）：</h3><p><strong>一个数据库只有一个内模式</strong></p>
<ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式记录的存储方式<br>  （例如，顺序存储，堆存储，Cluste按hash方法存储等）<ul>
<li><p>索引的组织方式（B+树，Bitmap，Hash）</p>
</li>
<li><p>数据是否压缩存储数据是否加密</p>
</li>
<li><p>数据存储记录结构的规定—如定长&#x2F;变长，记录是否可以跨页存放等</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>DBMS提供三种模式的描述语言（DDL）来严格定义三种模式。</p>
<h2 id="两级映象：（外模式-x2F-模式，模式-x2F-内模式映象-）"><a href="#两级映象：（外模式-x2F-模式，模式-x2F-内模式映象-）" class="headerlink" title="两级映象：（外模式&#x2F;模式，模式&#x2F;内模式映象 ）"></a>两级映象：（外模式&#x2F;模式，模式&#x2F;内模式映象 ）</h2><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p>
<p>引入知识点：<strong>映象，这</strong>是一种对应规则，说明映象双方如何进行转换。</p>
<h3 id="1-外模式-x2F-模式映象"><a href="#1-外模式-x2F-模式映象" class="headerlink" title="1.外模式&#x2F;模式映象"></a><strong>1.外模式&#x2F;模式映象</strong></h3><p>首先我们要知道这是定义在外模式描述中</p>
<p>官方的概念是：把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系起来，保证逻辑独立性。</p>
<p>当模式改变时，只要对外模式&#x2F;模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的逻辑独立性，也就是数据的<strong>逻辑独立性</strong>。</p>
<p>个人理解是，我创建了一张表，有年龄这一字段，是int类型，我更改了类型为str类型，没有报错，那么对于我在这张表上之前输入的数据，不会改变，视图也不会改变</p>
<h3 id="模式-x2F-内模式映象"><a href="#模式-x2F-内模式映象" class="headerlink" title="模式&#x2F;内模式映象"></a><strong>模式&#x2F;内模式映象</strong></h3><p>映像是唯一的</p>
<p>首先我们要知道这是定义在模式描述中</p>
<p>官方概念:把描述全局逻辑结构的模式与描述物理结构的内模式联系起来,保证<strong>物理独立性</strong>。</p>
<p>当内模式改变时，比如存储设备或存储方式有所改变，只要模式&#x2F;内模式映象做相应的改变，使模式保持不变，则应用程式保持不变。</p>
<h1 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>所有实体及实体之间联系的关系的集合构成一个关系数据库</p>
<p><u>所有关系的集合</u></p>
<p>关系数据库模式是关系模式的集合。</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模型，只包含单一的数据结构——关系</p>
<p>实体以及实体间的各种联系均用单一的结构类型——关系来表示</p>
<p>关系模型中的数据的逻辑结构是一张扁平的二维表</p>
<p>建立在集合代数的理论基础上</p>
<p>关系模式通常可以简记为<br>R(U,D,DOM,F)</p>
<p>U:属性名集合</p>
<p>D：U中属性来自的域</p>
<p>DOM：属性向域的映像集合</p>
<p>F:数据依赖</p>
<p>其中，R为关系名，A1，A2，…，An属性名</p>
<p>完整性约束</p>
<p>关系的<strong>目</strong>：列数。</p>
<h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>一组具有相同数据类型的值的集合，反映在二维表中则是某一列的单元格的值的取值范围。</p>
<p>{‘男’，‘女’}&#x2F;介于2007年7月1日到2008年2月29日之间的日期</p>
<h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>一种集合运算</p>
<p>$$D _ { 1 } \times D _ { 2 } \times \cdots D _ { n } &#x3D; { ( d _ { 1 } , d _ { 2 } , \cdots d _ { n } ) | d _ { i } ∈ D _ { i }}$$</p>
<p>所有域的所有取值的一个组合<br>不能重复</p>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>笛卡尔积中每一个元素</p>
<p>$( d _ { 1 } , d _ { 2 } , \cdots d _ { n })$</p>
<h4 id="分量"><a href="#分量" class="headerlink" title="分量"></a>分量</h4><p>$( d _ { 1 } , d _ { 2 } , \cdots d _ { n })$的$d_{i}$</p>
<h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><p>多少个元组</p>
<p>D1&#x3D;{张清玫，刘逸}，基数：2</p>
<p>D2&#x3D;{计算机专业，信息专业}，基数：2</p>
<p>D3&#x3D;{李勇，刘晨，王敏}，基数：3</p>
<p>D1×D2×D3的基数2×2×3&#x3D;12</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>D1×D2×…Dn的子集叫作在域D1,D2,…Dn上的关系，表示为：R(D1,D2,…Dn)</p>
<p>R为关系名，n为关系的目或度</p>
<h4 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h4><p>关系中的每个元素是关系中的元组，通常用t表示。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>关系中不同列可以对应相同的域，但必须对每列起一个名字，称为属性（Attribute）</p>
<p>属性的取值范围为域。</p>
<p>n目关系必有n个属性。</p>
<h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><p>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</p>
<p>最简单：有且只有一个属性能唯一标识元组，即候选码只包含一个属性。<br>最极端：所有属性组合起来才能唯一标识元组，即候选码包含全部属性，称为全码（All-key）</p>
<p>候选码的各个属性称为主属性（Primeattribute）<br>不包含在任何侯选码中的属性称为非主(码)属性（Non-key attribute）</p>
<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><p>判断候选码<br><strong>已知:</strong> AB-&gt;C;<br><strong>自反</strong>：AB-&gt;AB；<br><strong>合并</strong>：AB-&gt;ABC;</p>
<p>已知: B-&gt;D;<br><strong>增广</strong>：AB-&gt;AD;</p>
<p>已知: A-&gt;B,B-&gt;C<br><strong>传递</strong>：A-&gt;C</p>
<h5 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h5><p>若一个关系有多个候选码，则选定其中一个为主控使用者，称为主码（Primary key）</p>
<h4 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h4><p>二维表	</p>
<h4 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h4><h5 id="基本关系（又称为基本表或基表）"><a href="#基本关系（又称为基本表或基表）" class="headerlink" title="基本关系（又称为基本表或基表）"></a>基本关系（又称为基本表或基表）</h5><p>实际存在的表，是实际存储数据的逻辑表示</p>
<h5 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h5><p>查询结果对应的表，虚表</p>
<h5 id="视图表"><a href="#视图表" class="headerlink" title="视图表"></a>视图表</h5><p>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>列是同质的（Homogeneous）：每一列中的分量是同一类型的数据，来自同一个域。</p>
<p>不同的列可出自同一个域：每一列称为一个属性。不同的属性要给予不同的属性名。</p>
<p>列的顺序无所谓</p>
<p>行的顺序无所谓</p>
<p>任意两个元组的码不能相同：码的唯一性</p>
<p>分量必须取原子值：一个属性分为两个部分（[导师]–&gt;[导师1]+[导师2]）是不被允许的。</p>
<h3 id="关系模式与关系"><a href="#关系模式与关系" class="headerlink" title="关系模式与关系"></a>关系模式与关系</h3><p>关系模式是静态的、稳定的（属性名集合）<br>关系是动态的、随时间不断变化的（整张表）</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>查询<br>选择（找到）、投影（选出其中的某些列）、连接、除、并、差、交、笛卡尔积等<br>数据更新<br>插入、删除、修改</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><p>具有关系代数和关系演算双重特点的语言–SQL（StructuredQueryLanguage）</p>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><p> 关系的三类完整性约束,实体完整性和参照完整性适用于任何关系数据库系统,是关系模型必须满足的完整性约束条件，应该由关系系统自动支持</p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>所有主属性不能取空值</p>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>关系的引用</p>
<h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><p><strong>外码</strong>（外键）（ForeignKey）<br>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码。<br>基本关系R称为参照关系(Referencing Relation)</p>
<p>基本关系S称为被参照关系(Referenced Relation)或目标关系(Target Relation)</p>
<p><strong>外码的特点</strong><br>目标关系S的主码K_s和参照关系的外码F必须定义在同一个（或一组）域上。</p>
<p>取下面两类值：<br>（1）空值<br>表示尚未分配。<br>（2）非空值<br>必须一一对应</p>
<p><u>外码并不一定要与相应的主码同名</u>，但当外码与相应的主码属于不同关系时，往往取相同的名字便于识别。</p>
<ul>
<li>学生、课程、学生与课程之间的多对多联系</li>
</ul>
<p>学生（学号，姓名，性别，专业号，年龄）【被参照关系】</p>
<p>课程（课程号，课程名，学分）【被参照关系】</p>
<p>选修（学号，课程号，成绩）【参照关系】中学号和课程号分别是外码，合在一起作为选秀的主码。</p>
<p>选修（学号，课程号，成绩）中学号和课程号分别是外码，合在一起作为选秀的主码。</p>
<ul>
<li>学生实体及其内部的联系</li>
</ul>
<p>学生（学号，姓名，性别，专业号，年龄，班长）中，班长是外码。【既是被参照关系也是参照关系】</p>
<h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><p>用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的要求。</p>
<h4 id="两个不变性"><a href="#两个不变性" class="headerlink" title="两个不变性"></a>两个不变性</h4><p>实体完整性<br>参照完整性</p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>五种基本关系代数：包括<u>并 (∪)、差 (-)、广义笛卡尔积 (×)、投影 (π)和选择 (σ)</u>，其他运算的功能都可以由这五种基本运算来实现。</p>
<p>关系代数运算是以集合运算为基础的运算。</p>
<p>关系代数运算的三大要素</p>
<p>运算对象：关系</p>
<p>运算结果：关系</p>
<p>运算符：四类</p>
<p><img src="/images%5C1664849284855.png" alt="1664849284855"></p>
<p>R和S<br>具有相同的目n（即两个关系都有n个属性）<br>相应的属性取自同一个域<br>t是元组变量，t∈R表示t是R的一个元组</p>
<h4 id="并"><a href="#并" class="headerlink" title="并"></a>并</h4><p>R∪S&#x3D;{t|t∈R∨t∈S}</p>
<p>仍为n目关系，由属于R或属于S的元组组成</p>
<h4 id="差"><a href="#差" class="headerlink" title="差"></a>差</h4><p>R—S&#x3D;{t|t∈R∧不属于S}</p>
<p>仍为n目关系，由属于R而不属于S的所有元组组成</p>
<p>关系代数表达式R－（R－S），表达的是<strong>R∩S</strong>。</p>
<h4 id="交"><a href="#交" class="headerlink" title="交"></a>交</h4><p>假设2：<br>R是n目关系，包含k1个元组<br>S是m目关系，包含k2个元组</p>
<h4 id="笛卡尔积-1"><a href="#笛卡尔积-1" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>列：（n+m）列的元组的集合。<br>元组的前n列是关系R的一个元组；<br>后m列是关系S的一个元组。行：k1×k2个元组</p>
<p><img src="/images%5C1664849671016.png" alt="1664849671016"></p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h4><p><img src="/images%5C1664850275837.png" alt="1664850275837"></p>
<h3 id="专门"><a href="#专门" class="headerlink" title="专门"></a>专门</h3><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>选择又称为限制（Restriction）</p>
<p>$σ_F (R)$</p>
<p>F：选择条件，是一个逻辑表达式，取“真”或“假”值，其基本形式为：XθY<br>θ：比较运算符（＞，≥，＜，≤，＝或&lt;&gt;）</p>
<p>$σ_{5 &#x3D; ‘is’} $意思为第五个属性</p>
<p>$σ_{5&lt;20} $第五个属性小于20</p>
<p>选择行</p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>从R中选择出若干属性列组成新的关系，是从列的角度进行运算。  </p>
<p>$π_A(R)$</p>
<p>查询学生关系Student中都有哪些系</p>
<p>$π_{Sdep}(Student)$</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>关系代数中的联接操作是由<strong>选择和笛卡尔积</strong>操作组合而成</p>
<p>连接也称为θ连接<br>从两个关系的笛卡尔积中选取属性间满足一定条件的元组。</p>
<p><img src="/images%5C1664851967414.png" alt="1664851967414"></p>
<p>从两个关系的<strong>笛卡尔积中选取</strong>属性间满足一定条件的元组。</p>
<p><img src="/images%5C1664852589235.png" alt="1664852589235"></p>
<h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p><img src="/images%5C1664852599794.png" alt="1664852599794"></p>
<h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>自然连接是一种特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组，在结果中把重复的属性列去掉</p>
<p><img src="/images%5C1664852609084.png" alt="1664852609084"></p>
<p>悬浮元组：两个关系R和S在自然连接时，关系R和S中被舍弃的元组称为悬浮元组。</p>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>用途：将不满足条件的悬浮元组也加入到输出结果之中。</p>
<p>外连接：如果把<strong>舍弃的元组也保存在结果关系中</strong>，而在其他属性上填空值(Null)，这种连接就叫做外连接（OUTER JOIN）。</p>
<h6 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h6><p>如果只把<strong>左边</strong>关系R中要舍弃的元组<strong>保留</strong>就叫做左外连接(LEFT OUTER JOIN或LEFT JOIN)</p>
<h6 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h6><p>如果只把<strong>右边</strong>关系S中要舍弃的元组<strong>保留</strong>就叫做右外连接(RIGHT OUTER JOIN或RIGHT JOIN)</p>
<h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><p>同时从行和列角度进行运算<br>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作<br>$$R \div S &#x3D; { t _ { r } [ X ] | t _ { r } ∈ R ∧ \pi _ { Y } ( S ) ⊆ Y _ { x } }$$</p>
<p><img src="/images%5C1664931126030.png" alt="1664931126030"></p>
<p><img src="/images%5C1664931138080.png" alt="1664931138080"></p>
<p><img src="/images%5C1664932633268.png" alt="1664932633268"></p>
<p><img src="/images%5C1664932665351.png" alt="1664932665351"></p>
<p>ABC&#x2F;BCD &#x3D; A(BC共有的部分的A)</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><h3 id="B-Tree数据结构"><a href="#B-Tree数据结构" class="headerlink" title="B-Tree数据结构"></a>B-Tree数据结构</h3><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>索引（Index）是一种特殊的数据结构，其作用相当于一本书的目录，可以用来快速查询数据库表中的特定记录。</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>1）从<strong>物理结构</strong>上可以分为聚集索引和非聚集索引两类：</p>
<ul>
<li><strong>聚簇索引</strong>指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的<strong>主键索引</strong>；</li>
<li><strong>非聚簇索引</strong>的逻辑顺序则与数据行的物理顺序不一致。</li>
</ul>
<p>2）从<strong>应用</strong>上可以划分为一下几类：</p>
<ul>
<li><strong>普通索引</strong>：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 <code>ALTER TABLE table_name ADD INDEX index_name (column)</code> 创建；</li>
<li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。通过 <code>ALTER TABLE table_name ADD UNIQUE index_name (column)</code> 创建；</li>
<li><strong>主键索引</strong>：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li>
<li><strong>组合索引</strong>：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li>
<li><strong>全文索引</strong>：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li>
</ul>
<h2 id="索引B-Tree和B-Tree"><a href="#索引B-Tree和B-Tree" class="headerlink" title="索引B-Tree和B+Tree"></a>索引B-Tree和B+Tree</h2><h2 id="B-Tree与hash索引的比较"><a href="#B-Tree与hash索引的比较" class="headerlink" title="B-Tree与hash索引的比较"></a>B-Tree与hash索引的比较</h2><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h2 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h2><h1 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h1><p>一个关系内部属性与属性之间的约束关系叫做数据依赖。</p>
<h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</p>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>设 R 为任一给定关系，如果对于 R 中属性 X 的每一个值，R 中的属性 Y 只有唯一值与之对应，则称 X 函数决定 Y 或称 Y 函数依赖于 X ，记作 X—&gt;Y。其中，X 称为决定因素。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="平凡函数依赖"><a href="#平凡函数依赖" class="headerlink" title="平凡函数依赖"></a>平凡函数依赖</h4><h4 id="非平凡函数依赖"><a href="#非平凡函数依赖" class="headerlink" title="非平凡函数依赖"></a>非平凡函数依赖</h4><h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><ul>
<li>如果存在 X 属性集（注意是集合，说明是联合主键）决定 唯一的 Y ，且 X 中的<strong>任一子集都不能决定</strong>唯一的 Y，则 Y 完全依赖于 X。</li>
<li>例如：学生数学成绩完全由该学生的学号和数学课决定，所以数学课成绩完全依赖于（学号，数学课）</li>
</ul>
<h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>多属性</p>
<ul>
<li>X 的属性集中任一子集可以决定唯一的 Y</li>
<li>例如：学生学号和姓名可以决定唯一的学生，但是学生号也可以决定唯一的学生</li>
</ul>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><ul>
<li><p>设 R 为任一给定关系， X Y Z 为其不同的属性子集，若 X —&gt; Y, Y 不决定 X 且 Y —&gt;Z，则有 X —&gt;Z，称为 Z 传递函数依赖于 X</p>
</li>
<li><p>例如：书的出版编号是唯一，版权归出版社所有，所以只能由该出版社出版。所以存在函数依赖：书出版编号—&gt;出版社名，出版社名—&gt;出版社地址，但是出版社名不能决定唯一的出版书编号，则有出版社地址传递函数依赖于出版书编号</p>
</li>
</ul>
<h4 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h4><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="投影性"><a href="#投影性" class="headerlink" title="投影性"></a>投影性</h4><h4 id="扩张性"><a href="#扩张性" class="headerlink" title="扩张性"></a>扩张性</h4><h4 id="合并性"><a href="#合并性" class="headerlink" title="合并性"></a>合并性</h4><h4 id="分解性"><a href="#分解性" class="headerlink" title="分解性"></a>分解性</h4><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><h3 id="候选码-1"><a href="#候选码-1" class="headerlink" title="候选码"></a>候选码</h3><p><strong>完全函数依赖</strong> U 则是候选码，一般键叫做候选键。</p>
<h3 id="超码"><a href="#超码" class="headerlink" title="超码"></a>超码</h3><p>部分函数依赖 U 则是超码，候选码是最小的超码。</p>
<h3 id="全码"><a href="#全码" class="headerlink" title="全码"></a>全码</h3><p>整个属性集是候选码 则是全码</p>
<h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><p>不是自己的关系模式R的候选码，但是是另一个关系模式的候选码</p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式是符合某一种级别的关系模式的集合 。<strong>范式</strong>是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>范式</td>
<td>范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。</td>
<td>查询时通常需要多表关联查询，更难进行索引优化</td>
</tr>
<tr>
<td>反范式</td>
<td>反范式的过程就是通过冗余数据来提高查询性能，可以减少表关联和更好进行索引优化</td>
<td>存在大量冗余数据，并且数据的维护成本更高</td>
</tr>
</tbody></table>
<h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。 </p>
<p>为了确保原子性的，也就是存储的数据具备不可再分性。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>2NF：在1NF基础上，数据表中每一条记录可唯一标识，所有非主键字段必须<strong>完全依赖</strong>于<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E9%94%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22475125865%22%7D">主键</a>，不能部分依赖于主键 ，<strong>消除部分函数依赖</strong>。</p>
<p>2NF设计原则：一张表只表达一个意思, 对于部分依赖于主键的字段，将这 部分字段 与 依赖的部分主键 抽取出来建立新表。</p>
<p>表中的每一列都要和主键有关。<strong>而不能只与主键的某一部分相关</strong>，不存在非主属性对码的部分函数依赖。</p>
<p>采用投影分解法将1NF变成2NF.</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>3NF：在2NF基础上，非主属性之间不能相互依赖，非主属性之间相互独立，<strong>消除传递依赖</strong>。不存在非主属性对码的传递函数依赖。</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>不存在主属性的对码的传递函数依赖</p>
<h2 id="根据范式分解"><a href="#根据范式分解" class="headerlink" title="根据范式分解"></a>根据范式分解</h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="更新异常"><a href="#更新异常" class="headerlink" title="更新异常"></a>更新异常</h3><p>更新复杂</p>
<h3 id="插入异常"><a href="#插入异常" class="headerlink" title="插入异常"></a>插入异常</h3><p>应该插入的未插入</p>
<h3 id="删除异常"><a href="#删除异常" class="headerlink" title="删除异常"></a>删除异常</h3><p>不该被删除的被删除</p>
<h3 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h3><p>出现各种问题的原因<br>关系模式属性列之间存在混乱的依赖关系</p>
<p>解决方法<br>通过分解关系模式来消除其中不合适的数据依赖。</p>
<h2 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a>安全控制</h2><h3 id="账户控制"><a href="#账户控制" class="headerlink" title="账户控制"></a>账户控制</h3><h3 id="日志控制"><a href="#日志控制" class="headerlink" title="日志控制"></a>日志控制</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一组要执行的SQL,要么都执行成功，要么都不执行</p>
<p>事务是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<p>在MlySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务；</p>
<p>事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。<br>事务用来管理insert,update,delete语句。</p>
<p><strong>事务结束</strong>指的是事务提交成功(COMMIT)&#x2F;事务回滚(ROLLBACK)</p>
<h4 id="事务使用场景"><a href="#事务使用场景" class="headerlink" title="事务使用场景"></a>事务使用场景</h4><p>开启事务后再写数据来保证正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br><span class="line">COMMIT #事务正常结束</span><br><span class="line">ROLLBACK #事务异常终止，回滚到开始前状态（要么都执行要不都不执行）</span><br><span class="line"></span><br><span class="line">---1</span><br><span class="line">BEGIN</span><br><span class="line">READ A</span><br><span class="line">A=A-M</span><br><span class="line">IF A&lt;0</span><br><span class="line">ROLLBACK</span><br><span class="line">IF A&gt;=0</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><h5 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h5><h5 id="不能重复读"><a href="#不能重复读" class="headerlink" title="不能重复读"></a>不能重复读</h5><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><h4 id="特性ACID"><a href="#特性ACID" class="headerlink" title="特性ACID"></a>特性ACID</h4><h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p>最小单位，逻辑单位，要么都执行要不都不执行</p>
<h5 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h5><p>从一个一致性到另一个一致性的状态</p>
<h5 id="隔离性isolation"><a href="#隔离性isolation" class="headerlink" title="隔离性isolation"></a>隔离性isolation</h5><p>一个事务的执行不能被其他事务干扰</p>
<h4 id="隔离级别-按照级别排序"><a href="#隔离级别-按照级别排序" class="headerlink" title="隔离级别(按照级别排序)"></a>隔离级别(按照级别排序)</h4><h5 id="1-读未提交：read-uncommitted"><a href="#1-读未提交：read-uncommitted" class="headerlink" title="- (1)读未提交：read uncommitted"></a>- (1)<strong>读未提交</strong>：read uncommitted</h5><p>提供了事务间最小限度的隔离。</p>
<p><strong>实现原理</strong><br><u>读不加锁，写加排它锁（X锁）</u><br><u>直接读磁盘中的数据</u></p>
<p>  事物A和事物B,，事物A未提交的数据，事物B可以读取到<br>  这里读取到的数据叫做<strong>“脏数据”</strong><br>  这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别。</p>
<p> 理解：公司发工资了，领导把5000元打到A的账号上，但是该事务并未提交，而A正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给A的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后A实际的工资只有2000元。</p>
<h5 id="2-读已提交rc：read-committed"><a href="#2-读已提交rc：read-committed" class="headerlink" title="- (2)读已提交rc：read committed"></a>- (2)<strong>读已提交</strong>rc：read committed</h5><p>在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。</p>
<p>  这种级别可以避免“脏数据”这种隔离级别会导致<strong>“不可重复读</strong>取</p>
<p><strong>实现原理</strong>	<br><u>读不加锁,做“快照读”并总是读最新的快照</u><br><u>写加排它锁(X锁)</u></p>
<h5 id="3-可重复读rr：repeatable-read"><a href="#3-可重复读rr：repeatable-read" class="headerlink" title="- (3)可重复读rr：repeatable read"></a>- (3)<strong>可重复读</strong>rr：repeatable read</h5><p>保证同一事务在执行同条SELECT语句数次， <strong>结果总是相同的</strong>。 </p>
<p><strong>实现原理</strong><br><u>读不加锁,做“快照读”</u><br><u>并总是读事务开始第一次读的那个版本的快照（Undo日志中）</u><br><u>写加排它锁(X锁)</u></p>
<p> 可能会导致<strong>幻读</strong>。</p>
<p> A的老婆工作在银行部门，她时常通过银行内部系统查看A的信用卡消费记录。有一天，她正在查询到A当月信用卡的总消费金额(select sum(amount)from transaction where month&#x3D;本月）为80元，而A此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录(insert transaction…),并提交了事务，随后A的老婆将A当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，A的老婆很诧异，以为出现了幻觉，幻读就这样产生了。</p>
<h5 id="实现-MVCC（多版本并发控制）-写-读"><a href="#实现-MVCC（多版本并发控制）-写-读" class="headerlink" title="!实现:MVCC（多版本并发控制）(写+读)"></a>!实现:MVCC（多版本并发控制）(写+读)</h5><p>MYSQL中<strong>可重复读和提交读</strong>隔离级别的<strong>实现方式</strong></p>
<p>MVCC的核心就是 Undo log+ Read-view，</p>
<p>•MVCC是通过undo日志来实现•<strong>读不加锁,做“快照读”</strong></p>
<p>“MV”就是通过 Undo log（回滚的基础）来保存数据的历史版本，实现多版本的管理</p>
<p>“CC”是通过 Read-view（读视图）来实现管理，通过 Read-view原则来决定数据是否显示。</p>
<p>同时针对不同的隔离级别， Read view的生成策略不同，也就实现了不同的隔离级别。</p>
<h5 id="4-串行化：serializable"><a href="#4-串行化：serializable" class="headerlink" title="- (4)串行化：serializable"></a>- (4)<strong>串行化</strong>：serializable</h5><p>用户之间通过一个接一个顺序执行当前的事务，提供了事务之间最大限度的隔离。</p>
<p>t1 -&gt; t2和t2 -&gt; t1</p>
<p>实现原理:<br><u>读加共享锁（S锁)</u><br><u>写加排它锁(X锁)</u>  </p>
<p>事务A和事务B,事务A在操作数据库时，事务B只能排队等待，直到事务A提交(反之事务B一样）<br> 这种隔离级别很少使用，吞吐量太低，用户体验差<br> 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发</p>
<h5 id="持续性"><a href="#持续性" class="headerlink" title="持续性"></a>持续性</h5><p>改变是永久的</p>
<h3 id="INNODB级别日志"><a href="#INNODB级别日志" class="headerlink" title="INNODB级别日志"></a>INNODB级别日志</h3><p>储存引擎的日志</p>
<p>Undo_log</p>
<p>Redo_log</p>
<p>实现特性的方式</p>
<h1 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h1><h4 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h4><p>数据库的锁有 排他锁，共享锁，意向锁，自增锁，间隙锁，锁的范围有包括，行锁，表锁 ，区间锁。数据库的锁有 排他锁，共享锁，意向锁，自增锁，间隙锁，锁的范围有包括，行锁，表锁 ，区间锁。</p>
<h5 id="排他锁-x2F-写锁：X"><a href="#排他锁-x2F-写锁：X" class="headerlink" title="排他锁&#x2F;写锁：X"></a>排他锁&#x2F;写锁：X</h5><p>X 锁，事务T加了排他锁，自己<strong>可读也可写</strong>。禁止并发操作。</p>
<p>Xlock</p>
<h5 id="共享锁-x2F-读锁：S"><a href="#共享锁-x2F-读锁：S" class="headerlink" title="共享锁&#x2F;读锁：S"></a>共享锁&#x2F;读锁：S</h5><p>S 锁，相对于悲观锁来说，是低一级的锁，若有事务对于某一条数据加了共享锁后，其他事务依旧可以增加共享锁，但是不能增加排他锁。</p>
<p>允许其他用户可查询 不可修改</p>
<p>slock</p>
<h4 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h4><p>R(x):读数据x</p>
<p>W(x):写数据x</p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p><u>封锁协议级别越高，一致性程度越高</u></p>
<h4 id="一级封锁协议-写前加写锁"><a href="#一级封锁协议-写前加写锁" class="headerlink" title="一级封锁协议-写前加写锁"></a>一级封锁协议-写前加写锁</h4><p>事务在<strong>修改</strong>之前需要加<strong>X</strong>锁，事务结束解锁。(其他事务不能加锁，但是可以直接读)</p>
<p>解决<u>丢失更新</u>。</p>
<p><strong>可以防止丢失修改，并且保证事务可恢复</strong></p>
<h4 id="二级封锁协议-读前加读锁，读完释放"><a href="#二级封锁协议-读前加读锁，读完释放" class="headerlink" title="二级封锁协议-读前加读锁，读完释放"></a>二级封锁协议-读前加读锁，读完释放</h4><p>base one level，事务在<strong>读</strong>之前加<strong>S</strong>锁，<strong>读完</strong>释放。</p>
<p>解决<u>污读</u></p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>事务T1封锁了数据R,事务T2又请求封锁R,于是T2等待；T3也请求封锁R,当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待；T4又请求封锁R,当T3释放了R上的封锁之后系统又批准了T4的请求2有可能永远等待，产生活锁.</p>
<p>采用<strong>先来先服务策略</strong>即可解决。</p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>事务T1封锁了数据R1,T2封锁了数据R2,T1又请求封锁R2,因T2已封锁了R2,于是T1等待T2释放R2上的锁，接着T2又申请封锁R1,因T1已封锁了R1,T2也只能等待T1,释放R1上的锁，这样T1在等待T2,而T2又在等待T1,T1和T2两个事务永远不能结束，形成死锁.</p>
<p>(1)死锁的预防<br>1.一次封锁法：每个事务必须一次将<strong>所有要使用的数据全部加锁</strong>，否则就不能继续执行<br>2.顺序封锁法：预先对数据对象规定一个封锁顺序，<u>所有事务按这个顺序实施封锁</u></p>
<p>(2)死锁的诊断与解除<br>诊断：</p>
<ol>
<li><strong>超时法</strong>：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li>
<li><strong>等待图法</strong>：构建事务等待图(有向图：节点表示运行的事务，边表示事务等待的情况)，存在回路即死锁解除：<u>选择一个处理死锁代价最小的事务，将其撤销(UNDO),</u>释放此事务持有的所有的锁</li>
</ol>
<h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>对任何数据进行读写前，需要获得该数据的封锁；当事务在释放任何一个封锁之后，不得再获得其他封锁。</p>
<p>遵循两段锁，是可串行化的充分条件，也是可能发生死锁的。</p>
<h4 id="三级封锁协议-读前加读锁，事务结束释放"><a href="#三级封锁协议-读前加读锁，事务结束释放" class="headerlink" title="三级封锁协议-读前加读锁，事务结束释放"></a>三级封锁协议-读前加读锁，事务结束释放</h4><p>base one level，事务在<strong>读</strong>之前加<strong>S</strong>锁，<strong>事务结束</strong>释放。</p>
<p>（事务T在读取数据之前必须先对其加共享锁，排它锁)</p>
<p>解决<u>重复读</u></p>
<h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>封锁的粒度越大，并发度就越小，系统开销也越小。<br>封锁的粒度越小，并发度较高，但系统开销也就越大</p>
<h4 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h4><p>在一个系统中同时支持多种封锁粒度供不同的事务选择</p>
<h4 id="多粒度树"><a href="#多粒度树" class="headerlink" title="多粒度树"></a>多粒度树</h4><p>以<strong>树形结构</strong>来表示多级封锁粒度，<strong>根结点是整个数据库</strong>，表示<strong>最大的数据粒度</strong>，<strong>叶结点</strong>表示<strong>最小的数据粒度</strong>。</p>
<p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>分为：</p>
<p>意向共享锁(Intent Share Lock，简称IS锁)<br>意向排它锁(IntentExclusive Lock，简称IX锁)<br>共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)SIX&#x3D;S+IX</p>
<p><u>Q：具有意向锁的多粒度封锁方法减少了加锁和解所的开销：</u></p>
<p>在加锁时只要从根结点检查到要<strong>加锁的结点</strong>，而<strong>不需要考虑后代结点</strong>，而后代结点的个数远远大于祖先结点，因而减少了加锁时检查的开销。</p>
<p>同时由于后代结点<strong>不需要显示加锁</strong>，从而也减少了解锁的开销。</p>
<h3 id="相容性矩阵"><a href="#相容性矩阵" class="headerlink" title="相容性矩阵"></a>相容性矩阵</h3><table>
<thead>
<tr>
<th>X</th>
<th>请求的模式</th>
<th>IS</th>
<th>S</th>
<th>IX</th>
<th>SIX</th>
</tr>
</thead>
<tbody><tr>
<td>否</td>
<td>意向共享 (IS)</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>否</td>
<td>共享 (S)</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>否</td>
<td>意向排他 (IX)</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>否</td>
<td>意向排他共享 (SIX)</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>否</td>
<td>排他 (X)</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>加入事务T1对数据对象A加了S锁，也就意味着它对A的所有下级结点加了隐式S锁，现在事务T2想要申请数据对象上的<strong>IS</strong>锁，由于IS锁表示T2将要对A的下级结点加<strong>S</strong>锁，根据S锁的定义S锁和S锁式相容的，所以T2的封锁请求可以满足，也就是说S锁和IS锁是相容的。</p>
<p>首先要明确下面的结论</p>
<ul>
<li>1.这个矩阵表示 两个事务T1 T2是否可以 同时 对同一个对象加指定的锁。</li>
<li>2.对于SIX&#x3D;S+IX锁的理解，虽然两个不同事务是不允许同时向同一对象加S，IX锁的。但是在一个事务中是可以即加S锁又加IX锁的的。因为锁就是保护事务并发的正确性，读和写两种命令在一个事务里就不存在并发的几种错误情况。但看一个事务就不需要考虑并发。理论上可以在一个事务里对同一对象又加S锁又加X锁，但根本没这个必要。</li>
</ul>
<hr>
<ul>
<li>T1加S锁，表示数据的子节点都是隐式的加了 S 锁<ul>
<li>T2 加 S 相容 都是读锁</li>
<li>T2 加 IS 相容 都是读锁</li>
<li>T2 加 IX ，不相容， IX 对子节点 意向 加 X 锁（逻辑上可能不会对子节点加 X ，但是只要这个可能性存在就要保证正确性） ，和 S 锁冲突</li>
<li>T2 加 SIX, 不相容， 同 上面加 IX</li>
<li>T2 加 X ， 不相容， S 和 X 冲突</li>
</ul>
</li>
<li>T1加X锁，<ul>
<li>T2只能干等着。因为X锁排他，优先级最高</li>
</ul>
</li>
<li>T1加IS锁<ul>
<li>T2不能加X锁。因为T1有对其子节点加S锁的可能而T2扼杀了这个可能性。</li>
<li>T2 加 IX锁 相容 是因为I锁只是意向锁，所以是可行的，若事务有非意向锁，根据相容矩阵再次判定。SIX锁综上同理。</li>
</ul>
</li>
<li>T1加IX锁，<ul>
<li>T2不能加S，X，SIX锁的原因不再赘述。(不能加SIX锁的原因，可参考不能加S锁)</li>
</ul>
</li>
<li>T1加SIX锁，<ul>
<li>T2只能加IS锁。不能加S，X，IX，SIX锁的原因分别是：</li>
<li>T2 加 S 不相容，T1无法完成SIX锁的IX部分</li>
<li>T2 加 X 不相容，T1首先就无法完成S锁，更别说SIX锁</li>
<li>T2 加 IX 不相容，表示T2意向修改对象子节点，而T1要读对象，若T2修改其子节点便产生并发错误。故pass</li>
<li>T2 加 SIX 不相容，综合上面S和IX的情况。pass</li>
</ul>
</li>
</ul>
<h1 id="恢复技术"><a href="#恢复技术" class="headerlink" title="恢复技术"></a>恢复技术</h1><h4 id="常见损坏"><a href="#常见损坏" class="headerlink" title="常见损坏"></a>常见损坏</h4><h5 id="事务内部故障"><a href="#事务内部故障" class="headerlink" title="事务内部故障"></a>事务内部故障</h5><p>事务没有到达终点.</p>
<ul>
<li>可预期</li>
<li>不可预期<ul>
<li>运算溢出</li>
<li>发生死锁, 被选中撤销</li>
<li>违反完整性约束</li>
</ul>
</li>
</ul>
<h5 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h5><ul>
<li>cpu</li>
<li>操作系统</li>
<li>代码错误</li>
<li>断电</li>
</ul>
<h5 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h5><p>硬故障,外存故障</p>
<p>发生可能性小,破坏性大.</p>
<ul>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>瞬时强磁场干扰.</li>
</ul>
<h5 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h5><p>人为破坏</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理:"></a>基本原理:</h4><p><strong>数据冗余</strong></p>
<h4 id="恢复实现"><a href="#恢复实现" class="headerlink" title="恢复实现"></a>恢复实现</h4><p>如何建立冗余数据:</p>
<h5 id="1-数据转储-备份backup"><a href="#1-数据转储-备份backup" class="headerlink" title="1. 数据转储(备份backup);"></a>1. <strong>数据转储</strong>(备份backup);</h5><p>   定期将数据复制到磁带磁盘和其他存储介质.(提前写转储计划) </p>
<p>   后备副本</p>
<p>   转储方法:</p>
<h6 id="1-静态转储和动态转储"><a href="#1-静态转储和动态转储" class="headerlink" title="(1)静态转储和动态转储"></a>(1)静态转储和动态转储</h6><p>   静态:系统中无运行事务时进行,得到的一定是一个数据一致性的副本.</p>
<p>   转储必须等正在运行的用户事务结束.</p>
<p>   动态:</p>
<h6 id="2-海量转储和增量转储"><a href="#2-海量转储和增量转储" class="headerlink" title="(2)海量转储和增量转储"></a>(2)海量转储和增量转储</h6><p>   海量:全部备份</p>
<p>   增量:只转储上次转储后更新过的数据</p>
<p>增量备份通过二进制日志来实现。</p>
<h5 id="2-登记日志文件-logging"><a href="#2-登记日志文件-logging" class="headerlink" title="2. 登记日志文件(logging)"></a>2. 登记日志文件(logging)</h5><p>   原则:</p>
<p>   Ⅰ. 先写日志文件,后写数据库</p>
<p>   原因:若颠倒,日志上没有登记下修改,以后无法恢复这个修改.</p>
<p>   Ⅱ. 登记的次序要严格按照并发事务执行的时间</p>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><h5 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h5><p><strong>UNDO</strong></p>
<h5 id="系统故障（软故障）"><a href="#系统故障（软故障）" class="headerlink" title="系统故障（软故障）"></a>系统故障（软故障）</h5><p>系统故障的情况下，在系统重新启动后，恢复子系统除了需要撤销<strong>UNDO</strong>未完成的事务以外，还需要<strong>REDO</strong>（事务重做）<br>所有已提交的事务。</p>
<h5 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h5><ol>
<li>重装数据库<br>装入最新的后备数据库副本,<strong>恢复到最近一次一致性状态</strong>.</li>
<li>重做<strong>REDO</strong></li>
</ol>
<h5 id="计算及病毒会产生上述故障"><a href="#计算及病毒会产生上述故障" class="headerlink" title="计算及病毒会产生上述故障"></a>计算及病毒会产生上述故障</h5><p>采用相应的恢复策略</p>
<h3 id="mysql备份工具"><a href="#mysql备份工具" class="headerlink" title="mysql备份工具"></a>mysql备份工具</h3><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>备份结果为可读的SQL文件，可用于跨版本跨平台恢复数据。<br>备份文件的尺寸小于物理备份，便于长时间存储。<br>mysql发行自带工具，无需安装第三方软件<br>Mysqldump热备全量逻辑备份</p>
<p>导出逻辑备份数据，备份较慢<br>还原需要执行sql语句，速度较慢<br>由于mysqldump的备份原理是对数据库发出很多条select请求,所以对数据库造成一定的负担。</p>
<h4 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h4><p>第三方percano公司研发的免费的物理备份工具<br>直接备份INNODB底层数据文件<br>导出不需要转换为SQL语句，速度快<br>工作时对数据库的压力较小</p>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>一、数据库设计的生存期</p>
<p>① <strong>需求分析</strong></p>
<p>需求收集和分析，得到用数据字典描述的数据需求，用数据流图描述的处理需求。明确数据的生命周期， 存储<br>特点。</p>
<p>分析用户以及应用系统的数据需求<br>明确在数据库中需要存储和管理的数据<br>明确用户对数据的安全性和完整性方面的需求<br>明确数据的生命周期，存储特点（案例参考）</p>
<p>② <strong>概念结构设计</strong></p>
<p>对需求进行综合、归纳与抽象，形成一个<strong>独立于具体DBMS的概念模型</strong>（用E-R表示）。借助E-R模型，表达数据抽象结果，得到独立于具体的DBMS的概念模型</p>
<p>③ <strong>逻辑结构设计</strong></p>
<p>将概念结构转换为某个DBMS所支持的数据模型（例如关系模型），并对其进行优化。关系规范化理论。</p>
<p>对于关系模型，将关系模型转换为关系数据库模式<br>遵循转换规则<br>运用关系规范化理论</p>
<p>④ <strong>物理结构设计</strong></p>
<p>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。</p>
<p>程序设计：应用程序设计的工作开始于物理设计</p>
<p>采用数据定义语言定义数据库模式<br>确定适合应用环境的存储结构和存取方法</p>
<p>⑤ <strong>数据库实施</strong></p>
<p>运用DBMS提供的数据语言（例如SQL）及其宿主语言（例如C），根据逻辑设计和物理设计的结果</p>
<p>建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</p>
<p>建立数据库<br>进行数据库编程<br>组织数据入库<br>测试数据库</p>
<p>⑥ <strong>数据库运行和维护</strong></p>
<p>数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改。</p>
<p>对数据库进行评估<br>完善数据库<br>重组织<br>重构造</p>
<p>说明：设计一个完善的数据库应用系统是不可能一蹴而就的，它往往是上述六个阶段的不断反复。</p>
<p>二、数据库设计阶段的内容</p>
<p>三、数据库设计阶段的模式</p>
<p>数据库结构设计的不同阶段形成数据库的各级模式，如下图。</p>
<p>需求分析阶段：综合各个用户的应用需求；</p>
<p>概念设计阶段：形成独立于机器特点，独立于各个DBMS产品的概念模式，即E-R图；</p>
<p>逻辑设计阶段：将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式；然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的外模式；</p>
<p>物理设计阶段：根据DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。</p>
<h1 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h1><p>第四章：数据库安全性（授权）<br>1、不安全因素<br>①非授权用户对数据库的恶意存取和破坏<br>②数据库中重要数据的泄露<br>③安全环境的脆弱性<br>2、数据库安全性控制<br>①用户身份鉴别：静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别<br>②存取控制<br>③自主存取控制方法<br><strong>3、为什么要授权</strong><br>授权是指授予(GRANT)和收回(REVOKE),是数据库安全性控制中的自主存取控制方法。是为了保护数据库<br>防止不合法使用所造成的数据泄露、更改或破坏。<br>4、如何授权：授予GRANT<br>发出如下语句的可以是数据库管理员、也可以是数据库对象创建者、也可以是已经拥有该权限的用户<br>GRANT权限ON对象类型对象名TO用户名WITH GRANT OPTION];<br>权限：查询权限SELECT,全部操作权限ALL PRIVILEGES<br>对象类型&amp;对象名：对象类型可以是TABLE也可以是VEW,对象名为对应的表名或者视图名<br>用户名：可以是指定用户，也可以是全体用户PUBLIC<br>如果没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限<br>注意：SQL不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先<br>eg.把查询权限授给用户U1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON TABLE Student TO U1;</span><br></pre></td></tr></table></figure>

<p>5、收回授权：收回REVOKE<br>REVOKE权限ON对象类型对象名FROM用户名[CASCADERESTRICT,<br>CASCADE:级联回收。将用户传播出去的权限一并收回<br>RESTRICT:受限回收。若用户传播过该权限，回收将会失败<br>eg.把用户U4修改学生学号的权限收回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span>(Sno)<span class="keyword">ON</span> <span class="keyword">TABLE</span> Student <span class="keyword">FROM</span> U4;</span><br></pre></td></tr></table></figure>

<p>6、创建数据库模式的权限<br>对抢创建数据库模式一类的数据库对象的授权再数据库管理员创建用户时实现：<br>CREATE USER username [WITH DBARESOURCECONNECT];<br>只有系统的超级用户才有权创建一个新的数据库用户，新创建的数据库用户有三种权限：DBA、RESOURCE、<br>CONNECT（此为默认）<br>DBA：可以创建新用户、创建模式、创建基本表和视图等，拥有对所有数据库对象的存取权限，还可以把这些权限<br>授予一般用户<br>RESOURCE:可以创建基本表和视图，但不能创建模式和新用户。数据库对象的属主可以用GRANT语句把该对象<br>上的存取权限授予其他用户<br>CONNECT：只能登陆数据库，根据其他用户或者数据库管理员授予的权限的情况对数据库对象进行权限范围内的<br>操作<br>7、数据库角色<br>角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过<br>程<br>创建角色：CREATE ROLE角色名；<br>在一个角色中添加角色或者用户：GRANT角色TO某角色&#x2F;某用户WITH ADMIN OPTION]:<br>指定NITH ADMIN OPTION子句，则获得某种权限的角色或者用户还可以把这种权限再授予其他角色</p>
<p>5、收回授权：收回REVOKE<br>REVOKE权限ON对象类型对象名FROM用户名[CASCADERESTRICT,<br>CASCADE:级联回收。将用户传播出去的权限一并收回<br>RESTRICT:受限回收。若用户传播过该权限，回收将会失败<br>eg.把用户U4修改学生学号的权限收回<br>REVOKE UPDATE(Sno)ON TABLE Student FROM U4;<br>6、创建数据库模式的权限<br>对抢创建数据库模式一类的数据库对象的授权再数据库管理员创建用户时实现：<br>CREATE USER username [WITH DBARESOURCECONNECT];<br>只有系统的超级用户才有权创建一个新的数据库用户，新创建的数据库用户有三种权限：DBA、RESOURCE、<br>CONNECT（此为默认）<br>DBA：可以创建新用户、创建模式、创建基本表和视图等，拥有对所有数据库对象的存取权限，还可以把这些权限<br>授予一般用户<br>RESOURCE:可以创建基本表和视图，但不能创建模式和新用户。数据库对象的属主可以用GRANT语句把该对象<br>上的存取权限授予其他用户<br>CONNECT：只能登陆数据库，根据其他用户或者数据库管理员授予的权限的情况对数据库对象进行权限范围内的<br>操作<br>7、数据库角色<br>角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过<br>程<br>创建角色：CREATE ROLE角色名；<br>在一个角色中添加角色或者用户：GRANT角色TO某角色&#x2F;某用户WITH ADMIN OPTION]:<br>指定NITH ADMIN OPTION子句，则获得某种权限的角色或者用户还可以把这种权限再授予其他角色</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>记录发生的错误。</p>
<h2 id="慢查日志"><a href="#慢查日志" class="headerlink" title="慢查日志"></a>慢查日志</h2><p>记录执行时间超过指定时间的操作。</p>
<h2 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h2><p>所有向mysql发出的请求。</p>
<h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>记录全部有效的数据修改日志。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常用软件的安装教程</title>
    <url>/2023/02/25/test/%E5%A6%82%E4%BD%95%E7%99%BD%E5%AB%96office%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p>支持正版！</p>
<span id="more"></span>

<h1 id="1-office系列"><a href="#1-office系列" class="headerlink" title="1. office系列"></a>1. office系列</h1><ol>
<li>参考视频：<a href="https://www.bilibili.com/video/BV1g64y1d7az?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1g64y1d7az?spm_id_from=333.999.0.0</a></li>
<li>下载office tool plus</li>
<li>部署完毕</li>
<li>输入命令&#x2F;osppilbyid ProPlus2021Volume &#x2F;osppsethst:kms.loli.beer &#x2F;osppsetprt:1688 &#x2F;osppact</li>
</ol>
<p>kms.cangshui.net（这个命令经常会变，请上网找到最新的命令）</p>
]]></content>
  </entry>
  <entry>
    <title>动手学深度学习v2补充解释</title>
    <url>/2023/11/13/test/%E6%9D%8E%E6%B2%90/</url>
    <content><![CDATA[<h1 id="动手学深度学习v2"><a href="#动手学深度学习v2" class="headerlink" title="动手学深度学习v2"></a>动手学深度学习v2</h1><p>个人不理解的地方，进行一些原理的证明或是详细解释。</p>
<span id="more"></span>

<h2 id="每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致"><a href="#每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致" class="headerlink" title="每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致"></a>每层的输出和梯度都看作随机变量，让他们的均值和方差都保持一致</h2><p>来源：14 模型初始化和激活函数</p>
<p>如果每层的输出和梯度都具有相同的均值和方差，那么在反向传播过程中，梯度会保持相同的比例。这样，梯度值在各层之间就不会发生太大的变化，从而减轻梯度消失或爆炸的问题。</p>
<p>假设每层的输出和梯度都具有相同的均值和方差，即： $$E[h^t] &#x3D; E[g^t] &#x3D; 0$$ $$Var[h^t] &#x3D; Var[g^t] &#x3D; \sigma^2$$ 在反向传播过程中，梯度是通过链式法则计算的： $$g^{t-1} &#x3D; \frac{d}{dh^{t-1}} L(h^t, y)$$ 其中，$L$ 是损失函数。 根据链式法则，我们有： $$g^{t-1} &#x3D; \sigma’(W^th^{t-1}) W^t$$ 其中，$\sigma$ 是激活函数。 由于 $h^{t-1}$ 和 $g^t$ 都具有相同的均值和方差，因此 $\sigma’(W^th^{t-1})$ 也具有相同的均值和方差。 因此，我们有： $$E[g^{t-1}] &#x3D; \sigma’(0) E[W^t] &#x3D; 0$$ $$Var[g^{t-1}] &#x3D; \sigma’^2(0) Var[W^t] &#x3D; \sigma^2$$ 因此，在反向传播过程中，梯度的均值保持为零，而梯度的方差保持为 $\sigma^2$。 也就是说，在反向传播过程中，梯度会保持相同的比例。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>K-means讲解</title>
    <url>/2023/11/15/test/k-means/</url>
    <content><![CDATA[<p>K-means的一些讲解</p>
<span id="more"></span>   

<meta name="referrer" content="no-referrer" />


<h1 id="k-均值算法"><a href="#k-均值算法" class="headerlink" title="k 均值算法"></a>k 均值算法</h1><p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/1234333422.gif"></p>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20201018202041.png"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h2><ul>
<li>随机选取样本作为初始均值向量（初始值：k 的值【即几个簇】）（也可以不用样本点）</li>
<li>分别计算每个样本点到初始均值向量的<strong>距离</strong>（数据做了标准化），距离哪个点最近就属于哪个簇</li>
<li>每个簇重新计算中心点，重复第二步直到<strong>收敛</strong></li>
<li>找到质心和离某个质心距离最近的点就分为一类。</li>
</ul>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20210210021340.png"></p>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20210210021518.png"></p>
<p><img src="https://gavin-pic-1302578220.cos.ap-beijing.myqcloud.com/img/20210210021531.png"></p>
<blockquote>
<p>问题：需要指定k值，难以确定k值。</p>
</blockquote>
<h2 id="确定k值"><a href="#确定k值" class="headerlink" title="确定k值"></a>确定k值</h2><h3 id="1-手肘法"><a href="#1-手肘法" class="headerlink" title="1.手肘法"></a>1.手肘法</h3><p>手肘法的核心指标是SSE(sum of the squared errors，误差平方和)，</p>
<p>$$S S E &#x3D; \sum _ { i &#x3D; 1 } ^ { k } \sum _ {  p∈m_i }| p - m _ {i } | ^ { 2 }$$</p>
<p>其中，Ci是第i个簇，p是Ci中的样本点，mi是Ci的质心（Ci中所有样本的均值），SSE是所有样本的聚类误差，代表了聚类效果的好坏。</p>
<p>手肘法的核心思想是：随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。并且，当k小于真实聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达真实聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的真实聚类数。当然，这也是该方法被称为手肘法的原因。</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/image-20231115213147472.png"></p>
<h3 id="2-轮廓系数法"><a href="#2-轮廓系数法" class="headerlink" title="2. 轮廓系数法"></a>2. 轮廓系数法</h3><p>思想：簇内样本的距离越近，簇间样本距离越远，平均轮廓系数越大，聚类效果越好。</p>
<p>该方法的核心指标是轮廓系数（Silhouette Coefficient），某个样本点Xi的轮廓系数定义如下：</p>
<p>$$S &#x3D; \frac { b - a } { m a x ( a , b ) }$$</p>
<p>其中</p>
<p>a是Xi与同簇的其他样本的平均距离，称为凝聚度</p>
<p>b是Xi与最近簇中所有样本的平均距离，称为分离度。</p>
<p>最近簇的定义是，簇间不相似，最近的不相似</p>
<p>$$C _ { j } &#x3D;{ a r g } m i n \frac { 1 } { n } \sum _ { p ∈c _ { s } } | p - X _ { i }| ^ { 2 }$$</p>
<p>其中p是某个簇Ck中的样本。事实上，简单点讲，就是用Xi到某个簇所有样本平均距离作为衡量该点到该簇的距离后，选择离Xi最近的一个簇作为最近簇。</p>
<p>求出所有样本的轮廓系数后再求平均值就得到了<strong>平均轮廓系数</strong>。</p>
<p>平均轮廓系数的取值范围为[-1,1]。</p>
<p>那么，很自然地，平均轮廓系数最大的k便是最佳聚类数。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>聚类算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建的图床配置问题</title>
    <url>/2023/11/15/test/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>因为我之前就有写一些md文件，并且有本地的图片存放处，所以要移植到博客中图片的位置要重新更改，比较麻烦。所以可以采用网络图床的方法，而gitee图床会有防盗链的问题。文末也给出了解决办法。</p>
<span id="more"></span>   

<meta name="referrer" content="no-referrer" />

<p>本文参考：<a href="https://zhuanlan.zhihu.com/p/583732805">https://zhuanlan.zhihu.com/p/583732805</a></p>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>Typora的下载安装和激活可以参考<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/wjdzh/p/16522182.html">这篇文章</a>或者其他博客，这里主要介绍PicGo的安装过程。</p>
<p>打开Typora，依次单击菜单栏【文件】&#x3D;&gt;【偏好设置】&#x3D;&gt;【图像】，会在页面上展示【下载PicGo】按钮，单击即可跳转下载页面。因为这里笔者做了主题颜色的修改，所以软件的背景是深色的，这个基本不影响本文的阅读。</p>
<p><img src="https://pic1.zhimg.com/80/v2-fea0257eb4c729201fc5e26266a8b474_1440w.webp" alt="img"></p>
<p>从Typora进入PicGo软件下载界面</p>
<p>在下载页面中单击【免费下载】，会跳转到github相应网站，下拉可以看到下载链接：例如笔者选择【PicGo-Setup-2.3.1.exe】这一项。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b5fac8e771ae60e3bc084a58e324e007_1440w.webp" alt="img"></p>
<p>单击免费下载</p>
<p><img src="https://pic4.zhimg.com/80/v2-40abd45ed1da8e980435daad3765323f_1440w.webp" alt="img"></p>
<p>转向github主页</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/v2-1d821f5ae80ccd249ba68aa8089eda91_1440w.webp" alt="img"></p>
<p>选择合适的文件进行下载</p>
<p>接下来就是程序安装过程，可以自定义程序的安装路径，这些操作比较简单。</p>
<p>注意如果想要正常使用PicGo，可能还需要安装<a href="https://link.zhihu.com/?target=https://nodejs.org/en/">NodeJS</a>环境，可以下载左侧稳定板，这个过程也是按部就班，按照提示进行安装即可。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e376d26a38218d47abc3df7877c5337d_1440w.webp" alt="img"></p>
<p>nodeJS下载</p>
<p>以上软件安装完毕后，就可以进行仓库的创建。</p>
<h3 id="GiTee账户令牌与仓库创建"><a href="#GiTee账户令牌与仓库创建" class="headerlink" title="GiTee账户令牌与仓库创建"></a>GiTee账户令牌与仓库创建</h3><p>Gitee账户的准备工作有以下几项工作需要做：</p>
<ol>
<li>创建账户</li>
<li>创建项目（也就是仓库）</li>
<li>修改仓库权限为公开</li>
<li>生成私人令牌</li>
</ol>
<p>如果读者还没有Gitee账户，需要先创建<a href="https://link.zhihu.com/?target=https://gitee.com/login">Gitee</a>账户，如果已有账号，可以直接登录。</p>
<p><img src="https://pic2.zhimg.com/80/v2-019866556acd3ccb1068ee7b969faff9_1440w.webp" alt="img"></p>
<p>Gitee登陆注册页面</p>
<p>然后需要创建一个公开仓库，按照以下操作进行配置。</p>
<p>首先新建仓库</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/v2-fa36c8dba361449a427f840933dd8dc7_1440w.webp" alt="img"></p>
<p>Gitee个人主页</p>
<p>配置仓库相关参数，这里暂时还不能修改仓库权限。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a01dffb661f597f1b4fabc913624584d_1440w.webp" alt="img"></p>
<p>创建仓库</p>
<p>新版Gitee无法再创建时选择权限，需要创建后在仓库设置中选择公开。在仓库界面单击选择【管理】，并且勾选相关单击【确定】。</p>
<p>进入仓库主页。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f17051a2605b4e6d4cda1237987a4ef1_1440w.webp" alt="img"></p>
<p>从个人主页进到仓库主页</p>
<p>进入仓库设置页面。</p>
<p><img src="https://pic2.zhimg.com/80/v2-885b8e694a36000b81964b455c797189_1440w.webp" alt="img"></p>
<p>单击右上角管理按钮</p>
<p>设置仓库权限为开源。</p>
<p><img src="https://pic2.zhimg.com/80/v2-21be13aa6bf02c6d34a52cf97b53f9b5_1440w.webp" alt="img"></p>
<p>设置为开源</p>
<p>接下来需要设置私人令牌，这个令牌相当于暗号或者密码，外部可以通过这个另外访问到当前账户下的数据，注意明文令牌只展示一次，需要及时保存在粘贴板中，后续要用到。</p>
<p><img src="https://pic4.zhimg.com/80/v2-34b0d953ec603e3c9a600e79f6a41ac7_1440w.webp" alt="img"></p>
<p>进入个人主页</p>
<p>进入个人主页设置。</p>
<p><img src="https://pic2.zhimg.com/80/v2-73675bf4d9e879015b287da80bf12485_1440w.webp" alt="img"></p>
<p>单击个人设置</p>
<p>在设置页面左侧找到【私人令牌】。</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/v2-45cc87ed7075951b3ff1d7859cb9e7d3_1440w.webp" alt="img"></p>
<p>左侧单击私人令牌</p>
<p>添加私人令牌。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e9f889cecda53684ebe557168b6ce153_1440w.webp" alt="img"></p>
<p>单击生成新令牌，这里笔者已经有了，所以页面上不是空的</p>
<p>配置私人令牌参数。</p>
<p><img src="https://pic1.zhimg.com/80/v2-14b41344f2a58fba70d35aaaae829c40_1440w.webp" alt="img"></p>
<p>创建私人令牌</p>
<p>注意令牌明文只展示一次，需要记录下来，后面要用。</p>
<p><img src="https://pic3.zhimg.com/80/v2-746fa20c3f5d4e4ba6b4a5dedafe75ea_1440w.webp" alt="img"></p>
<p>私人令牌只出现一次，需要及时记录下来</p>
<p>到此为止，Gitee仓库创建完成，个人的令牌也已经生成，接下来就是要把账户（Gitee用户名和仓库名）和密码（私人令牌）写在PicGo中。</p>
<h3 id="PicGo配置工作"><a href="#PicGo配置工作" class="headerlink" title="PicGo配置工作"></a>PicGo配置工作</h3><p>打开PicGo软件，做必要的安装配置。</p>
<ol>
<li>安装gitee－uploader插件</li>
<li>设置gitee相关账户、仓库和令牌</li>
<li>设置PicGo软件</li>
</ol>
<p>首先需要在【插件设置】中安装gitee插件，搜索gitee-uploader并单击安装，等待几分钟安装完毕。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8670fa2005cceff4f72fffdae7a59ed0_1440w.webp" alt="img"></p>
<p>在PicGo中设置GiteeUploader插件</p>
<p>安装后重启PicGo，可以在【图床设置】选项中看到下拉选项【Gitee】，单击并进行配置。</p>
<p><img src="https://pic2.zhimg.com/80/v2-953d6af335644b7112ba894967e51a59_1440w.webp" alt="img"></p>
<p>PicGo中Gitee配置</p>
<p>有以下几项：</p>
<ul>
<li>repo：在自己的Gitee账户下，单击刚刚创建的根目录，在浏览器的当前页面链接中复制最后的账户名和仓库名部分，例如笔者的这一栏填“softargmax&#x2F;blog-pic”。</li>
<li>branch：一般选择master</li>
<li>token：刚才在剪贴板中粘贴的私人令牌，直接复制过来</li>
<li>其他：保持默认即可</li>
</ul>
<p>注意账户名和仓库名要粘贴红色框里面的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-de04541b1a3730d9b4a27657aa2a92f0_1440w.webp" alt="img"></p>
<p>配置完毕后，单击【设为默认图床】和【确定】</p>
<p>对PicGo进行一些其他的设置，正常情况下，【设置Server】中的监听网址保持默认就好。</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/v2-a51cd449691b8fd8f47291088499c874_1440w.webp" alt="img"></p>
<p>一些配置</p>
<p><img src="https://pic1.zhimg.com/80/v2-a6f4d86a2a8faa7b1ec43ece1446a10c_1440w.webp" alt="img"></p>
<p>一些配置</p>
<p>在设置server中，默认应该是这样的IP配置，如果不是就修改成这样。</p>
<p><img src="https://pic4.zhimg.com/80/v2-cd0c79c97d5a299e33bb948aaca894e7_1440w.webp" alt="img"></p>
<p>PicGo的一些设置</p>
<p><img src="https://pic2.zhimg.com/80/v2-8c42a46a26854b305e675751e12c8585_1440w.webp" alt="img"></p>
<p>配置服务器</p>
<h3 id="Typora配置工作"><a href="#Typora配置工作" class="headerlink" title="Typora配置工作"></a>Typora配置工作</h3><p>这是最后一步，配置Typora，主要有以下工作：</p>
<ol>
<li>设置插入图片的时执行的操作为【上传图片】，并设置相应动作</li>
<li>配置上传服务为PicGoAPP，并且选择程序所在的安装路径</li>
<li>单击相应按钮进行验证测试</li>
</ol>
<p>返回刚才打开的PicGo的偏好设置，在【图像】界面进行设置：</p>
<p><img src="https://pic1.zhimg.com/80/v2-9f6b35fab118e7c6d6aad17aa428e290_1440w.webp" alt="img"></p>
<p>配置Typora</p>
<p>设置完成后，可以单击【验证图片上传选项】按钮，证实自己的操作是正确的。</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/v2-436692777d410ff135402d1b0e75f565_1440w.webp" alt="img"></p>
<p>验证图片上传功能</p>
<p>如果出现红色的faild字样，说明以上配置存在错误，可以从以下几个方面排查：</p>
<ul>
<li>检查仓库的权限是否被修改为公有</li>
<li>检查PicGo中的Gitee配置是否和账户中的情况一致，尤其是账户名和仓库名要选择从链接中粘出来的而不是别的</li>
<li>重启各个软件再次尝试。</li>
</ul>
<p>如果提示出现successful字样，则说明上述配置成功。具体使用时，有以下现象：</p>
<ul>
<li>在使用Typora编写markdown文档时，不论以何种方式（例如选择本地文件或者其他网页的url文件）添加图片，图片都会自动上传到自己Gitee账户下的仓库中，并且在markdown中将链接地址修改为该图片的Gitee外往访问链接，这些链接是可以通过python或其他方式进行自动爬虫同步本地的，当然也可以自己登录仓库下载，也就意味着本地不需要再保存markdown中用到的图片了。</li>
<li>打开仓库，可以看到按照时间戳排序的各个图片文件，可以供用户批量下载备份。</li>
<li>在PicGo的【相册】栏目中也会出现通过该软件上传过的图片。</li>
</ul>
<h3 id="解决博客上传不显示的问题"><a href="#解决博客上传不显示的问题" class="headerlink" title="解决博客上传不显示的问题"></a>解决博客上传不显示的问题</h3><p>解决的办法很简单，就是在博客md首段添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>如图所下：</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/image-20231115223016431.png" alt="image-20231115223016431"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是端到端</title>
    <url>/2023/11/23/test/%E4%BB%80%E4%B9%88%E5%8F%AB%E7%AB%AF%E5%88%B0%E7%AB%AF/</url>
    <content><![CDATA[<p>端到端是深度学习中一个简单的概念。</p>
<span id="more"></span>   

<meta name="referrer" content="no-referrer" />



<p>我们可以将中文语音转英文文字的任务拆解成，语音转文字和中文翻译成英文两个任务。</p>
<p>而端到端的学习则是直接将这个任务放到神经网络中学习。</p>
<p>形成：输入-模型-目标，输入和目标就是两个端，直接通过一个模型便是端到端。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>参数与超参数</title>
    <url>/2023/11/17/test/%E5%8F%82%E6%95%B0%E4%B8%8E%E8%B6%85%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>参数与超参数的一些介绍，哪些是参数哪些是超参数</p>
<span id="more"></span>   

<meta name="referrer" content="no-referrer" />

<p>参数是可学习的，超参数需要自己设定的。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>给自己的环境装上jupyter</title>
    <url>/2023/11/20/test/%E8%A3%85%E4%B8%8Ajupyter/</url>
    <content><![CDATA[<span id="more"></span>   

<meta name="referrer" content="no-referrer" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 添加</span></span><br><span class="line">conda install ipykernel</span><br><span class="line"><span class="comment"># python -m ipykernel install --user --name [anaconda名称] --display-name &quot;[在jupyter的名称]&quot;</span></span><br><span class="line">python -m ipykernel install --user --name mytensor --display-name <span class="string">&quot;mytensor&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除</span></span><br><span class="line">jupyter kernelspec <span class="built_in">list</span></span><br><span class="line">jupyter kernelspec remove &lt;kernel_name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在base环境下，输入目标路劲，即可在网页中切换环境。</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>关于语音识别的科普</title>
    <url>/2023/11/23/test/%E5%A3%B0%E9%9F%B3/</url>
    <content><![CDATA[<p>关于语音识别的一些入门理解，</p>
<span id="more"></span>   

<meta name="referrer" content="no-referrer" />

<p>原视频指路：<a href="https://www.bilibili.com/video/BV1Km4y1Q7w7/?spm_id_from=333.337.search-card.all.click&vd_source=065dbebb8f309dd36ff6dbc4c04cbd15">https://www.bilibili.com/video/BV1Km4y1Q7w7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=065dbebb8f309dd36ff6dbc4c04cbd15</a></p>
<blockquote>
<p>1969年, 贝尔实验室的john peers在一封公开信中, 做出了一个悲观到刻薄的评论, 他将语音识别技术比作把水转化为汽油, 而他认为, 当时人们研究这项技术唯一的动机就是搞钱, 但现在我们知道已经不必再讨论能不能做, 而是怎么做的。 </p>
</blockquote>
<p>想要知道机器如何识别语音, 首先我们要理解<strong>什么是声音</strong>？ </p>
<p>声源振动挤压空气产生声波进入<strong>耳朵,</strong> 带动耳膜震动, 感知到声音。</p>
<p>机器的耳朵是麦克风, 声波带动麦克风上的膜片振动, 膜片带动套在磁铁上的线圈震动, 产生的声音的<strong>模拟信号</strong>。</p>
<p>而计算机是<strong>数字系统</strong>, 需要对模拟信号进行采样。 </p>
<p>人耳能听到的频率范围, 在20HZ到20KHZ。</p>
<p>根据<strong>香农奈奎斯特采样定理</strong>, 采样频率大于等于最大频率的两倍即可, 一般是44.1KHZ。</p>
<p>这样我们就得到了一段声音, 在计算机中的数字化格式，也就是我们经常看见的声波图。</p>
<p>语音识别就是<strong>把一段声波识别为对应的文字</strong>。</p>
<p><img src="https://gitee.com/insufficient-memory-space/image-bed/raw/master/image-20231124105103443.png" alt="image-20231124105103443"></p>
<p>这是一个频率为261.6, </p>
<p>256HZ的正弦波发出的声音是多, </p>
<p>而这是一个频率为293.6, </p>
<p>648HZ的正弦波发出的声音是rap, </p>
<p>所以当我们在听声音, </p>
<p>我们在听什么呢, </p>
<p>我们可以把振幅变大或变小, </p>
<p>声音的大小发生了变化, </p>
<p>但do还是do re还是re, </p>
<p>所以我们在听声音时, </p>
<p>实际上在听其中的频率, </p>
<p>换句话说, </p>
<p>声音的信息蕴含在频率之中, </p>
<p>但问题是从波形图中很难看出频率的信息, </p>
<p>这是哆来咪发唆拉西七个音的波形, </p>
<p>或许还能区分得开, </p>
<p>但如果同时发出哆咪嗦的音, </p>
<p>也就是C和弦, </p>
<p>这是它的波形, </p>
<p>而这是同时发出软发拉的DM和弦, </p>
<p>从波形图中看频率的事情就变得困难起来, </p>
<p>但我们可以换一种描述声音的方式, </p>
<p>横坐标表示频率值, </p>
<p>纵坐标表示频率的强度, </p>
<p>那么这些声音信号所蕴含的频率信息, </p>
<p>便可以一也看出, </p>
<p>即使是同时包含三个频率的和弦音, </p>
<p>也能一眼看出, </p>
<p>这样表示声音的图像成为平谱图, </p>
<p>而完成这种转换的就是信号处理领域, </p>
<p>非常常用的傅立叶变换, </p>
<p>工程实践中一般使用快速傅立叶变换FFT, </p>
<p>反过来说, </p>
<p>傅立叶变换告诉了我们这样一个事实, </p>
<p>一个信号可以表示为, </p>
<p>许多不同频率和强度信号的叠加, </p>
<p>即使是这样一个非周期不规则的信号, </p>
<p>所以在做语音识别之前, </p>
<p>为了更好的分析一段语音的信息, </p>
<p>需要把波形图转化为频率相关的频谱图, </p>
<p>当然一般不会直接对整段语音做傅立叶变换, </p>
<p>而是把它截成小段, </p>
<p>以确保不会错过其中的细节信息, </p>
<p>一般用一个长度为25ms的窗口, </p>
<p>从头开始截取25ms的语音信息, </p>
<p>成为第一帧, </p>
<p>然后向后滑动10ms, </p>
<p>再截取第二针, </p>
<p>再向后滑动10ms, </p>
<p>截取第三针, </p>
<p>以此类推, </p>
<p>这样一个一秒的语音就被截成了100帧, </p>
<p>截取出所有帧后, </p>
<p>接下来就是对每一帧的波形信号, </p>
<p>进行FFT变为频谱图, </p>
<p>当然人们向来是好奇的, </p>
<p>他们想要看看把所有真的频谱放在一起, </p>
<p>诊断语音在转换后是什么样子, </p>
<p>方法也很简单, </p>
<p>比如第一帧横坐标表示频率, </p>
<p>纵坐标表示该频率信号分量的强度, </p>
<p>那强度除了用纵坐标的值来表示, </p>
<p>用不同的颜色似乎也可以, </p>
<p>比如我们用从黑到黄表示不同大小的值, </p>
<p>这个0HZ的信号分量强度是300, </p>
<p>对应到一个颜色, </p>
<p>这个760HZ的信号强度是五, </p>
<p>对应到一个颜色, </p>
<p>这样就可以把曲线上每个频率对应的强do, </p>
<p>都转化成一个颜色, </p>
<p>得到一个色调, </p>
<p>其他帧也是如此, </p>
<p>我们再鉴定一个坐标系, </p>
<p>横坐标表示根号, </p>
<p>纵坐标表示频率, </p>
<p>把第一帧的色调放在第一帧的位置, </p>
<p>把第二针的色调放在第二针的位置, </p>
<p>以此类推, </p>
<p>最后就形成了一个叫做鱼谱图的东西, </p>
<p>横坐标表示第几帧, </p>
<p>纵坐标表示这一帧中蕴含哪些频率, </p>
<p>而颜色则表示这些频率信号的强度, </p>
<p>不过到此还未结束, </p>
<p>根据人类发声和听觉的特性, </p>
<p>还需要对原始频谱进行三角滤波, </p>
<p>然后取对数, </p>
<p>再经过DCT变换, </p>
<p>这是一个说起来非常琐碎的数学变换过程, </p>
<p>这个过程被称之为ml cc特征提取, </p>
<p>最终的效果就是, </p>
<p>把每一帧的频谱转化为一个, </p>
<p>39枚的特征向量, </p>
<p>一段语音信号, </p>
<p>最终也就被转化成了一个特征向量序列, </p>
<p>最后的特征向量序列才是要识别的数据, </p>
<p>在介绍正式的识别模型和算法之前, </p>
<p>我们先提一个非常普朴素的想法, </p>
<p>比如我们设计一个只能识别hi hello和word的系统, </p>
<p>那就先录制一些这些单词的语音, </p>
<p>Hello world, </p>
<p>经过ml cc提取出特征向量序列, </p>
<p>作为模板放进这个系统中, </p>
<p>这样对一个新的信号做预测时, </p>
<p>就和模板做对比, </p>
<p>也就是求解带预测语音的特征, </p>
<p>向量序列和这些模板中的向量序列的距离, </p>
<p>从而得到相似度, </p>
<p>相似度最大的便是识别的结果, </p>
<p>但直接和模板进行比较, </p>
<p>一看就很不高级啊, </p>
<p>不是主要是效果不好, </p>
<p>不过这个想法的意义在于, </p>
<p>虽然那些真正可用的识别模型和算法很复杂, </p>
<p>但基本思路与此并无区别, </p>
<p>而把这个想法用一个精简的数学公式来表达, </p>
<p>就是给定一个X出现W的概率, </p>
<p>X表示声音的特征, </p>
<p>W表示某个词, </p>
<p>P表示概率, </p>
<p>这个式子表示在S这段声音下, </p>
<p>结果是W的概率, </p>
<p>这就是一个条件概率问题, </p>
<p>那么语音识别的过程就是, </p>
<p>找到在声音X下出现概率最高的W, </p>
<p>但在人工神经网络流行之前, </p>
<p>直接对这个过程建模比较困难, </p>
<p>但利用概率统计学中人尽皆知, </p>
<p>又贼拉炫酷的贝叶斯公式, </p>
<p>就可以把这个问题转化为两个子问题, </p>
<p>因为我们要找W和X无关, </p>
<p>所以分母的可以直接忽略, </p>
<p>P of x, </p>
<p>given w表示一个单词发出某段语音信号的概率, </p>
<p>称为升学模型, </p>
<p>PW表示一个词出现的概率称之为语言模型, </p>
<p>质量模型就构成了一个语音识别系统, </p>
<p>我们先看声学模型部分, </p>
<p>从上个世纪80年代开始, </p>
<p>一直到本世纪初</p>
<p>点击折叠169行</p>
<p>总结概览要点</p>
<p>5分钟</p>
<p>点击生成</p>
<p>完整的要点提取</p>
<p>一种被称之为gmm hmm的方案, </p>
<p>始终占领着升学模型的主导地位, </p>
<p>我们来看看它是怎么运作的, </p>
<p>还是以识别hi hello和word这三个词为例, </p>
<p>首先我们采集这些词大量的语音数据, </p>
<p>但不再作为比较的模板, </p>
<p>而是把它们作为训练数据, </p>
<p>给每个词训练一个p of x given w模型, </p>
<p>训练完成后, </p>
<p>当我们将这三个模型中输入一段新的语音信号, </p>
<p>每个模型就会给出一个概率值, </p>
<p>所以这个模型是怎么建立的呢, </p>
<p>以hi这个词举例, </p>
<p>现在我们来详细的研究这些特征向量, </p>
<p>当然39维的向量并不便于作图和理解, </p>
<p>所以从现在开始到最后, </p>
<p>我们都假设这些向量是二维的, </p>
<p>如果我们把这些特征向量都绘制在一张平面, </p>
<p>直角坐标系上, </p>
<p>是这样子, </p>
<p>你会发现有的地方密集, </p>
<p>有的地方稀疏, </p>
<p>这样我们就可以使用一个高斯模型, </p>
<p>去拟合这些数据的分布, </p>
<p>得到一个概率密度函数, </p>
<p>第三个维度就表示这段语音是high, </p>
<p>这个词产生的概率高低, </p>
<p>这很合理, </p>
<p>在由high的训练数据形成的模型中, </p>
<p>如果一段带预测语音的特征向量, </p>
<p>在这些密集的区域, </p>
<p>则大概率是害, </p>
<p>如果在稀疏的区域, </p>
<p>则小概率是害, </p>
<p>但事情往往不会这样简单, </p>
<p>比如hello, </p>
<p>这个词在训练数据上的分布是这样的, </p>
<p>肉眼可见的是有两个密集区域, </p>
<p>一个高斯分布可能不太合适, </p>
<p>那就再加一个高斯, </p>
<p>做出两个鼓包的模型, </p>
<p>这就是高斯混合模型, </p>
<p>当然也有可能是三个, </p>
<p>四个或者五个等等, </p>
<p>这个模型的训练方法, </p>
<p>熟悉非监督学习的同学可能很清楚, </p>
<p>在训练数据上使用聚类算法就好, </p>
<p>在利用训练数据得到每个词的GMM模型之后, </p>
<p>现在要识别一段新的语音, </p>
<p>先通过MFCC把这段语音转成特征向量序列, </p>
<p>然后再把特征向量丢进每个词的GMM模型中, </p>
<p>计算出每个词发出这段语音的概率, </p>
<p>找到概率最大的即可, </p>
<p>不过你可能已经发觉得蹊跷, </p>
<p>每门语言中的字词数量太多了, </p>
<p>以英文举例, </p>
<p>现代英语的词汇量已经达到了几10万, </p>
<p>给每个词都建立模型显然不现实, </p>
<p>而且一个词的发音时间很长, </p>
<p>发出的音也很多变, </p>
<p>所以直接对词建立GMM模型往往效果很差, </p>
<p>但我们在英语课上学过一种叫做音标的东西, </p>
<p>虽然英语词汇的数量几10万, </p>
<p>但发音音素的数量却是固定的48个, </p>
<p>所以我们可以把单词high拆分为H和i hello, </p>
<p>拆分为hr lo, </p>
<p>这样我们只需要给这些因素建立GMM模型, </p>
<p>来识别一段语音中有哪些因素就好, </p>
<p>不过人们往往把音素分为更小的单位, </p>
<p>因为人们发现, </p>
<p>比如音速R后面接L的发音, </p>
<p>会和后面接其他因素时有一点不同, </p>
<p>同样前面结合也会影响它的发音, </p>
<p>所以把它前后的因素都考虑进去, </p>
<p>形成一个更小的识别单位称为, </p>
<p>不过实际上在做识别时, </p>
<p>每个三因素还是被拆成了若干个更小的单位, </p>
<p>这个单位称之为状态, </p>
<p>比如三个状态, </p>
<p>我们给每个状态建立GMM模型, </p>
<p>然后用识别出来的状态拼接成三, </p>
<p>用三音素拼接成音素, </p>
<p>再把音素拼接成词的音标, </p>
<p>而对于中文, </p>
<p>汉语拼音的23个声母和24个韵母, </p>
<p>相当于因素的角色, </p>
<p>到此似乎万事俱备, </p>
<p>但思考一个问题, </p>
<p>每个状态之间真的就像图像画的那样, </p>
<p>毫无关系吗, </p>
<p>声音作为一个序列信息, </p>
<p>前后之间必然会有某种联系, </p>
<p>也就是说一个三音速种, </p>
<p>每个状态之间也会有一定的转移概率, </p>
<p>当然也有可能转移到自己, </p>
<p>而原地打转, </p>
<p>那这些概率值是多少呢, </p>
<p>不知道需要通过大量的语音数据训练出来, </p>
<p>这实际上就是模型中的隐马尔可夫模型, </p>
<p>关于hmm的细节以及在连续语音识别中的过程, </p>
<p>理解起来还是很难的啦, </p>
<p>这里用单个因素为例, </p>
<p>简单的描述一下大致的流程, </p>
<p>这些是隐藏状态, </p>
<p>它们之间存在转移概率, </p>
<p>而下面的GMM仍旧在计算, </p>
<p>每个状态产生某阵语音信号特征向量的概率, </p>
<p>不过不再直接用来预测, </p>
<p>而是作为hmm模型需要的发射概率, </p>
<p>用大量的语音数据完成, </p>
<p>以马尔可夫模型和高斯混合模型的训练之后, </p>
<p>预测时搜索语音的特征向量序列, </p>
<p>经过高斯混合模型, </p>
<p>计算出以马尔可夫模型的发射概率, </p>
<p>而后以马尔可夫模型, </p>
<p>利用状态转移概率和发射概率, </p>
<p>搜索出概率值最大的因素, </p>
<p>所以以马尔可夫模型为何适合语音识别问题呢, </p>
<p>我们举个例子, </p>
<p>比如A这个字有人语速快啊, </p>
<p>有人语速慢啊, </p>
<p>在引入隐马尔可夫模型之后, </p>
<p>因为状态转移概率可以原地打转, </p>
<p>所以即使是拖长音状态, </p>
<p>多驻留一会儿就可以应对, </p>
<p>也就增强了不同发音风格的解析能力, </p>
<p>这就是流传许久的gmm hmm模型, </p>
<p>当然这只是一个声学模型, </p>
<p>最后识别出来的结果只是音标或者中文的拼音, </p>
<p>但一个拼音可能对应很多个字, </p>
<p>比如这段语音经过gmm hmm升学模型之后, </p>
<p>识别结果是能以李姐姐van vs未遂, </p>
<p>那如何得到最终的文字呢, </p>
<p>这就要利用语言模型部分, </p>
<p>所谓语言模型就是分析一句话像不像话, </p>
<p>比如把它识别为理解腕碎, </p>
<p>这就不像人话, </p>
<p>语言模型可能给出0.001的概率值, </p>
<p>而理解万岁则很像人话模型, </p>
<p>可能给出0.99的概率值, </p>
<p>结合语言模型最后得到识别的结果, </p>
<p>可以想象, </p>
<p>对于这几个发音一个更新及时的识别系统, </p>
<p>近些年给出理解万岁的概率必然大幅提升, </p>
<p>从而成为推荐词, </p>
<p>这就是从上个世纪80年代开始到本世纪初, </p>
<p>语音识别主流的技术线路, </p>
<p>但随着深度学习的兴起, </p>
<p>逐渐出现了, </p>
<p>只要能用上深度学习的, </p>
<p>最后就一定会用上深度学习这个现象, </p>
<p>这件事情在语音识别领域中发挥的淋漓尽致, </p>
<p>一开始深度学习还很保守, </p>
<p>只想取代前面的部分, </p>
<p>也就是ml c c, </p>
<p>既然ml cc是在把一段声音信号转化成特征向量, </p>
<p>而且ml cc里的手段都是人们手工建立的, </p>
<p>那训练一个深度神经网络, </p>
<p>让它自己提取出特征向量不香吗, </p>
<p>再然后深度学习的触角又升到了GMM</p>
<p>点击折叠160行</p>
<p>总结概览要点</p>
<p>4分钟</p>
<p>点击生成</p>
<p>完整的要点提取</p>
<p>既然GMM是一个因素发出某个语音的概率模型, </p>
<p>那么训练一个深度神经网络, </p>
<p>让它自己拟合出概率值不香吗, </p>
<p>这样原来的gmm hmm模型, </p>
<p>就变成了D等hmm模型, </p>
<p>另一方面, </p>
<p>除了声学模型, </p>
<p>语言模型, </p>
<p>这边, </p>
<p>像engram这样, </p>
<p>以循环神经网络为代表的深度学习模型, </p>
<p>正在飞速的取代传统方式, </p>
<p>最后深度学习彻底摊牌, </p>
<p>不装了, </p>
<p>隐马尔可夫模型也别留着了, </p>
<p>直接all in deep learning, </p>
<p>这样整个语音识别系统, </p>
<p>就变成了深度学习的天下, </p>
<p>比如基于循环神经网络的LAS模型, </p>
<p>以及CTCRNT等等, </p>
<p>我们说基于gmm hmm模型的传统语音识别系统, </p>
<p>中有声学模型, </p>
<p>语言模型, </p>
<p>实际上在因素拆解时还要有语言学的音素词典, </p>
<p>这些部分各自独立训练, </p>
<p>优化目标各不相同, </p>
<p>所以把它们连接在一起, </p>
<p>必然会导致识别精度的损失, </p>
<p>而深度学习可以直接在神经网络上训练, </p>
<p>P of fw given x, </p>
<p>这个模型最终的输出不再需要先划分为因素, </p>
<p>再组成拼音, </p>
<p>再转化成文字, </p>
<p>而是直接输出文字结果, </p>
<p>这就是所谓的端到端的识别框架, </p>
<p>输入语音经过模型直接识别出文字, </p>
<p>甚至不局限于识别, </p>
<p>比如输入一段英文, </p>
<p>Hello, </p>
<p>直接输出中文的翻译结果, </p>
<p>也就是说, </p>
<p>把翻译功能也在深度神经网络中给训练出来, </p>
<p>端到端的框架, </p>
<p>直接针对最终的目标优化模型, </p>
<p>省略了中间的转换和连接, </p>
<p>有更好的表现, </p>
<p>而深度学习作为一种强大的方法论, </p>
<p>使用起来也极具想象力, </p>
<p>这里有一个比较有意思的想法, </p>
<p>把语音识别问题转化为图像识别问题, </p>
<p>我们再来看看鱼谱图, </p>
<p>这些是理解万岁的于谱图, </p>
<p>而这些是你好, </p>
<p>世界的鱼谱图, </p>
<p>而这是图像识别中经典的猫狗识别问题, </p>
<p>这些是猫, </p>
<p>这些是狗, </p>
<p>想必你已经看出了端倪所在, </p>
<p>既然于谱图已经很好地体现了一段语音的特征, </p>
<p>有经验的语言学家, </p>
<p>甚至能直接从其中看出说话的内容, </p>
<p>那么为什么不能像识别一只猫或者一只狗那样, </p>
<p>直接去识别这些鱼谱图呢, </p>
<p>细细说来, </p>
<p>它们之间相似的地方非常的多, </p>
<p>比如这是一只中华田园猫, </p>
<p>这是一只加菲猫, </p>
<p>这是一段男性产生的理解万岁的离谱图, </p>
<p>而这是女性产生的同一类识别对象, </p>
<p>都可能有不同的个体特征, </p>
<p>这是在草地上的猫, </p>
<p>这是在室内的猫, </p>
<p>而这是在商场噪音下的理解万岁, </p>
<p>这是在火车站环境噪音下的理解万岁, </p>
<p>同一类识别对象都可能有不同的噪音背景, </p>
<p>所以把语音识别问题转化为图像识别问题, </p>
<p>是一个很妙的想法, </p>
<p>比如科大讯飞在2010年提出的DFCNN, </p>
<p>利用了图像识别领域中, </p>
<p>非常流行的卷积神经网络, </p>
<p>并借鉴了在图像识别中表现最好的网络配置, </p>
<p>搭建了一个很深的全序列卷积神经网络, </p>
<p>直接对语音的语谱图发起识别实验, </p>
<p>证明, </p>
<p>DCNN比当时在学术界和工业界, </p>
<p>最好的BRSTM的识别率, </p>
<p>提升了15%以上, </p>
<p>那么最后语音识别技术究竟走到了哪一步呢, </p>
<p>听说已经超越了人, </p>
<p>因为近些年总有媒体这么说, </p>
<p>是也不是这些对语音识别成果的震惊报道, </p>
<p>似乎不太喜欢提及一个事实, </p>
<p>训练和测试数据中的声音, </p>
<p>多是在理想环境下录制, </p>
<p>比如在安静的办公室, </p>
<p>甚至是专业的录音室, </p>
<p>但在被称为史上最难语音识别任务的, </p>
<p>掐米六比赛中, </p>
<p>数据集中的语音是这样的, </p>
<p>不可以, </p>
<p>So tx fy, </p>
<p>Just want these sides, </p>
<p>And there, </p>
<p>You can see the twenty five one, </p>
<p>这看起来就不像是现在的AI能搞定的问题, </p>
<p>科大讯飞采用了一种基于空间, </p>
<p>说话人同步感知的迭代野马估计算法, </p>
<p>简单来说就是使用麦克风阵列, </p>
<p>在复杂环境中综合考虑空间和说话人的信息, </p>
<p>对声音做进一步的处理, </p>
<p>最后把错误率从46.1%, </p>
<p>降低到了30.5%, </p>
<p>在这项国际赛事上完成了三连冠, </p>
<p>不过领先归领先, </p>
<p>30.5%的错误率, </p>
<p>却远远达不到好用的程度, </p>
<p>所以我们到底该不该报以理解万岁的态度呢, </p>
<p>可以但不完全的可以, </p>
<p>人们一般把人工智能的能力分为三个层次, </p>
<p>运算智能, </p>
<p>感知智能和认知智能, </p>
<p>运算智能人类已经一败涂地, </p>
<p>而感知智能近些年已经开始追求, </p>
<p>甚至超越了人类, </p>
<p>比如特定场景下的图像识别和语音识别, </p>
<p>机器越来越聪明比, </p>
<p>然而对于认知智能, </p>
<p>也就是像人一样, </p>
<p>能够自主应对复杂多变的现实场景, </p>
<p>我们到现在甚至没有找到正确的方向, </p>
<p>这种尴尬是语音识别乃至整个人工智能领域, </p>
<p>从感知智能进入到认知智能之前的常态, </p>
<p>所以可以理解, </p>
<p>但不完全可以理解的是, </p>
<p>那些试图超越技术发展阶段的产品, </p>
<p>逻辑安静, </p>
<p>你吵到我用TNT了, </p>
<p>找对语音识别的应用场景往往很重要, </p>
<p>我们来看一个正确的案例, </p>
<p>附着银宽度可和音像修复距离, </p>
<p>正常完善检查以后, </p>
<p>种植修复</p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title>关于大学的终点和研究生的起点</title>
    <url>/2023/11/24/test/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%96%B9%E5%90%91%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>对于大学的总结，希望警醒他人。</p>
<p>对于研究生方向选择的原因，希望不忘初心</p>
<span id="more"></span>   

<h2 id="我的故事和想法"><a href="#我的故事和想法" class="headerlink" title="我的故事和想法"></a>我的故事和想法</h2><p>大一的时候自己对于一切都好奇极了，当时也是个ENTJ，混迹在各种创业竞赛，宣传活动之中，对于学习也是随便的态度，大一上只有33名，大一下还挂了一门大物。</p>
<p>当时评奖学金发现我在我们班成绩居然还能评到二等奖学金，但是挂科了没有资格去参评。错失1500让我感到很沮丧。</p>
<p>一般人挂科了，都会觉得一切都结束了，保研没有希望了，再也没有卷绩点的意义了。但我觉得我更卷了，本质上我还是一个十分争强好胜的人，我觉得挂科是一件十分丢脸的事情，好歹我也是江苏高中TOP2（非官方，这是老师领导开会这么说的，虎扑评分TOP1）毕业的，我必须要做些什么证明自己是有实力的。在大创组队的时候，那些排名靠前的人，也都自己组成了队，问了好几个自己欣赏的人，都说自己已经组好了队。于是我下定决心要证明自己的能力。</p>
<p>于是在接下来的大创，我拿到了我们专业最好的立项。我也从33名到了7名，在各种汇报展示中SLAY全场（其实是我们专业的人不善于展示答辩，我认为我是我们专业最会答辩的人，PPT做的最好的人），运气好拿到了几个竞赛的奖。</p>
<p>但由于挂科，我知道自己无缘保研，对于考研我觉得我没有办法投入半年做一些题目，这很没有意义，所以我将目标放在了申请制的学校。我本科和数学计算机都有关系，但是都不深入，我深知自己计算机能力还不如计算机专业一半的人，9月之前一直在准备申请港新的数据科学，当时单纯抱着混一年水硕回来找工作的态度。进了几个数据科学的申请群，感觉里面的人有点奇怪有点聒噪，貌似很多是商科转过来的。我觉得自己不能融入他们精英主义的圈层，也对数据科学失去了点兴趣。</p>
<p>对于挂科这件事，我也是有些遗憾的。在我大二成绩已经可以保研的时候，遗憾的情绪达到了顶点，和别的学校的朋友说这件事情，他们和我提到，他们学校挂一门或者补考通过是可以推免的，我遗憾于学校的制度不好，更遗憾过去的自己没有一个明确的目标导致错失机会。我抱着试试看的心态，向学校教务处，学工处，校长信箱发了邮件，提出了我的建议，给他们看了其他学校的文件，大都没有回应。大三的时候，看到上一届的规则还是没有改变，我想大概是没有希望的了。于是没有什么遗憾的情绪，直面现在的处境，并且海外研也有它的好处，我这样宽慰自己，但心中仍然有一种期待。</p>
<p>大三暑假，作为INTP，我发现自己面试能力变得很差，我报了几个国内数据科学的夏令营想提前体验一下面试的过程，但不幸都没有入选。但我也没什么，毕竟去了我拿到了offer却不能去，这是更让人难过的事情。于是在别人都去夏令营中争取一个好offer的时候，我暑假去公司实习了ai岗。公司是制造业企业，所以在技术上没有帮助到我什么，但在完成项目落地的时候，我发现人工智能应用是有趣的并且有用的，也有很多知识值得好好研究。</p>
<p>科研或许需要一些兴趣才能坚持，我决定以后好好做科研了，就做深度学习，还是想在学术中多呆一会。我甚至当时去了解了海外直博，这是性价比最高的。当时也想着先报名试试看，不行就GAP一年，好好做点成果再去申请海外博。</p>
<p>但在有的学校预推免都关闭的时候，在我考好了雅思成绩的时候，辅导员突然告诉我有可能我也可以推免，那时候我也仍然不能十分确定我能不能拿到这个资格。 于是每天晚上我都忐忑于最后没有给我这个名额，我现在是否还要去预推免。</p>
<p>在申请的时候，看到了gtsi可以通过保研报考，我想这是最适合我的项目。毕竟佐治亚理工的计算机实力很好，想去的天大实验室也是我喜欢的（下面会说为什么）。相当于在深圳体验了那种一年授课硕，又能在国内完成科研任务。要是真的去普通的院校，我怕我也会后悔没有体验到海外硕士的感觉。<strong>体验是我人生中最重要的事情</strong>。最后拿到了gtsi的合格证，我觉得这是最好的去处了，我也在投递材料中感到疲累。没有什么心思再报什么更好的学校了。我也放弃了山大和东蒙的offer，华师的面试。</p>
<p>对于研究方向，我选了一个语音实验室，本科时候其实傅里叶和小波分析学的很差，但是对信息论有些感兴趣。在研究生选择方向的时候，还是选择语音深度学习。图像和文本的任务我都有所接触，让我觉得有些无聊，想去新的领域探索一番。</p>
<p>另外还有一个理由，是我看到国外有音乐&#x2F;艺术和深度学习结合的研究和相关的学者，虽然对于音乐我五音不全也没有乐感，但或许我仍然可以借助深度学习来创作我的音乐作品，这也是一种表达的途径。所以语音是和音乐相关的，这或许可以帮助我成为一名摇滚科学家。</p>
<p>我也真的想要探究音乐是如何让我收获这样的感动，音乐确实救过我，我认为音乐关乎人的幸福感，健康，生存。</p>
<p>我也认为做任何事情都是有有它本身的节奏的，在紧张的时候我发现哼歌可以让我更从容，音乐帮助我有了自己的节奏。</p>
<p>希望自己可以一直在这个方向探索下去，我还是坚持兴趣是最好的老师这个简单的道理。</p>
<hr>
<h2 id="保研过程的反思"><a href="#保研过程的反思" class="headerlink" title="保研过程的反思"></a>保研过程的反思</h2><p>对于保研过程，我也写了一些较为功利的东西，我不是个喜欢功利的人，但可能功利也没什么不好的，最起码能够达成目标，不至于成为失败者。</p>
<p>机会都是争取来的，在校遇到的那些每天坐在第一排认真听课的人他们对于专业知识上的掌握必然比我高，但问题是在保研期间我们能否能把握住机会。<br>信息战永远是重头戏，保研期间的 ddl 一般都很紧，一不小心就错。网络上有绿群的存在，但我都不知道。到最后两天我才知道。<br>对于想要保研的人来说，在大一就应该知道什么是保研，最起码我是不知道的，只知道努力提高绩点。保研分两方面，一方面是拿到学校的资格，另一方面是拿到外校的 offer。<br>学校的资格也并非全部都是绩点组成，是否有科研竞赛加分项，如果有请记得另辟蹊径。<br>外校的 offer 如何获取，或许在大一你就该看大四人的经验贴，大一就开始刷机试题，准备科研内容，准备常见的专业知识，准备面试的技巧，准备英语口语问答。<br>但是有一个明确的目标还是最为关键的，如果你从大一就开始有目标，你完全可以提前联系外校老师，尝试加入课题组暑期实习生之类，或者研读课题组相关论文。到时候你的眼前不是应接不暇的机遇，有机会，就可能会充满了遗憾。而是一条你已经构想好的大路，直接向着目标前进，可能没有意外之喜但是平坦且顺畅的。<br>如果一开始你就想出国申请博士，你也完全可以去参加暑期夏令营，提前联系教授，做他相关领域的成果，对他的领域了如指掌。<br>当然，这些都是我的后话，反思我大学期间，确实对于未来的目标规划不够明确，能有如今的结果，完全是我误打误撞来的，我并不知道数学建模竞赛对于保研综合成绩的影响力，也不知道一项专利对于国奖评定的分值标准。我其实在保研前一个月才确定自己想要学什么方向，也会后悔如果之前多做一点科研多练习一点口语多刷一点笔试，多看一点各个学校的面经，我会不会有更好的结果。<br>但我确实又是个得过且过的人，我认为已经足够幸运。我可以体验一年海外授课硕，也可以在语音人工智能领域继续学习。<br>但我也知道目标的实施肯定不会一帆风顺，光是稳定绩点就需要很多努力，更别说精进科研，会有学不下去的日子会有没有成果的困顿。<br>在大学期间我也浪费很多时间，并不是一个痴迷于学习的好学生，所以我想人各有命，机遇和实力都是必不可少的。</p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
